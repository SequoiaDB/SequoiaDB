<html>
<head>
  <title>BEAM: Builtin Checks</title>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>

<div id="wrap">

<table class="center">

<td id="left">
  <img src="images/logo.png" /><br />
  <ul id="navlist">
    <li id="navtitle">Information</li>
    <li><a href="whatis.html">What is BEAM</a></li>
    <li><a href="impatient.html">BEAM for the Impatient</a></li>
    <li><a href="links.html">Links</a></li>
    <li><a href="myths.html">Myths</a></li>
    <li><a href="index.html">Home</a></li>
    <li><a href="sitemap.html">Sitemap</a></li>

    <li id="navtitle">New Stuff</li>
    <li><a href="beam_trace.html">Build Tracing</a></li>
    <li><a href="windows.html">Windows Port</a></li>
    <li><a href="java.html">Java Support</a></li>
    <li><a href="eclipse/index.html">Eclipse Plug-in</a></li>

    <li id="navtitle">Releases</li>
    <li><a href="install.html">Download</a></li>
    <li><a href="schedule.html">Schedule</a></li>
    <li><a href="history.html">History</a></li>

    <li id="navtitle">Documentation</li>
    <li><a href="quick.html">Quick start guide</a></li>
    <li><a href="install.html">Installation Instructions</a></li>
    <li><a href="customize.html">BEAM Customization</a></li>
    <li><a href="compilers.html">Compiler Emulation</a></li>
    <li><a href="build.html">Build Integration Guide</a></li>
    <li><a href="builtin.html">Built-in Checks</a></li>
    <li><a href="parms.html">Built-in Parameters </a></li>
    <li><a href="attributes.html">Function Attributes</a></li>
    <li><a href="reference.html">Reference Docs</a></li>
    <li><a href="appnotes.html">Application Notes</a></li>
    <li><a href="faq.html">FAQ</a>

    <li id="navtitle">Contact</li>
    <li><a href="mailing-lists.html">Mailing Lists</a></li>
    <li><a href="http://spacedog.fishkill.ibm.com/beambugz/bugreport.cgi">Report a bug</a></li>
  </ul>
</td>

<td id="right">
<p>

</p>
<p>

</p>
<p>
<h1 class="title">Builtin Checks</h1>
<hr/>

</p>
<p>
<h2>Errors</h2>

</p>
<p>
<table class="borderless">
  <tr>
    <td valign="top">
      <ul>
        <li><a href="#ERROR1">ERROR1</a>
        <li><a href="#ERROR2">ERROR2</a>
        <li><a href="#ERROR3">ERROR3</a>
        <li><a href="#ERROR4">ERROR4</a>
        <li><a href="#ERROR5">ERROR5</a>
        <li><a href="#ERROR6">ERROR6</a>
        <li><a href="#ERROR7">ERROR7</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#ERROR8">ERROR8</a>
        <li><a href="#ERROR9">ERROR9</a>
        <li><a href="#ERROR10">ERROR10</a>
        <li><a href="#ERROR11">ERROR11</a>
        <li><a href="#ERROR12">ERROR12</a>
        <li><a href="#ERROR13">ERROR13</a>
        <li><a href="#ERROR14">ERROR14</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#ERROR15">ERROR15</a>
        <li><a href="#ERROR16">ERROR16</a>
        <li><a href="#ERROR17">ERROR17</a>
        <li><a href="#ERROR18">ERROR18</a>
        <li><a href="#ERROR19">ERROR19</a>
        <li><a href="#ERROR20">ERROR20</a>
        <li><a href="#ERROR21">ERROR21</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#ERROR22">ERROR22</a>
        <li><a href="#ERROR23">ERROR23</a>
        <li><a href="#ERROR24">ERROR24</a>
        <li><a href="#ERROR25">ERROR25</a>
        <li><a href="#ERROR26">ERROR26</a>
        <li><a href="#ERROR27">ERROR27</a>
        <li><a href="#ERROR28">ERROR28</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#ERROR29">ERROR29</a>
        <li><a href="#ERROR30">ERROR30</a>
        <li><a href="#ERROR31">ERROR31</a>
        <li><a href="#ERROR32">ERROR32</a>
        <li><a href="#ERROR33">ERROR33</a>
        <li><a href="#ERROR34">ERROR34</a>
        <li><a href="#ERROR35">ERROR35</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#ERROR36">ERROR36</a>
        <li><a href="#ERROR37">ERROR37</a>
        <li><a href="#ERROR38">ERROR38</a>
        <li><a href="#ERROR39">ERROR39</a>
        <li><a href="#ERROR41">ERROR41</a>
        <li><a href="#ERROR43">ERROR43</a>
        <li><a href="#ERROR44">ERROR44</a>
      </ul>
    </td>
  </tr>
</table>
</p>
<p>
<h2>Mistakes</h2>

</p>
<p>
<table class="borderless">
  <tr>
    <td valign="top">
      <ul>
        <li><a href="#MISTAKE1">MISTAKE1</a>
        <li><a href="#MISTAKE2">MISTAKE2</a>
        <li><a href="#MISTAKE3">MISTAKE3</a>
        <li><a href="#MISTAKE4">MISTAKE4</a>
        <li><a href="#MISTAKE5">MISTAKE5</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#MISTAKE6">MISTAKE6</a>
        <li><a href="#MISTAKE7">MISTAKE7</a>
        <li><a href="#MISTAKE8">MISTAKE8</a>
        <li><a href="#MISTAKE10">MISTAKE10</a>
        <li><a href="#MISTAKE11">MISTAKE11</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#MISTAKE12">MISTAKE12</a>
        <li><a href="#MISTAKE13">MISTAKE13</a>
        <li><a href="#MISTAKE14">MISTAKE14</a>
        <li><a href="#MISTAKE15">MISTAKE15</a>
        <li><a href="#MISTAKE16">MISTAKE16</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#MISTAKE17">MISTAKE17</a>
        <li><a href="#MISTAKE18">MISTAKE18</a>
        <li><a href="#MISTAKE19">MISTAKE19</a>
        <li><a href="#MISTAKE20">MISTAKE20</a>
        <li><a href="#MISTAKE21">MISTAKE21</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#MISTAKE22">MISTAKE22</a>
        <li><a href="#MISTAKE23">MISTAKE23</a>
        <li><a href="#MISTAKE24">MISTAKE24</a>
        <li><a href="#MISTAKE25">MISTAKE25</a>
      </ul>
    </td>
  </tr>
</table>
</p>
<p>
<h2>Warnings</h2>

</p>
<p>
<table class="borderless">
  <tr>
    <td valign="top">
      <ul>
        <li><a href="#WARNING1">WARNING1</a>
        <li><a href="#WARNING2">WARNING2</a>
        <li><a href="#WARNING3">WARNING3</a>
        <li><a href="#WARNING4">WARNING4</a>
        <li><a href="#WARNING5">WARNING5</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#WARNING6">WARNING6</a>
        <li><a href="#WARNING7">WARNING7</a>
        <li><a href="#WARNING8">WARNING8</a>
        <li><a href="#WARNING9">WARNING9</a>
        <li><a href="#WARNING10">WARNING10</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#WARNING11">WARNING11</a>
        <li><a href="#WARNING12">WARNING12</a>
        <li><a href="#WARNING13">WARNING13</a>
        <li><a href="#WARNING14">WARNING14</a>
        <li><a href="#WARNING15">WARNING15</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#WARNING16">WARNING16</a>
        <li><a href="#WARNING17">WARNING17</a>
        <li><a href="#WARNING18">WARNING18</a>
        <li><a href="#WARNING19">WARNING19</a>
        <li><a href="#WARNING20">WARNING20</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#WARNING21">WARNING21</a>
        <li><a href="#WARNING22">WARNING22</a>
        <li><a href="#WARNING24">WARNING24</a>
      </ul>
    </td>
  </tr>
</table>
</p>
<p>
<h2>Portability, Security, JNI</h2>

</p>
<p>
<table class="borderless">
  <tr>
    <td valign="top">
      <ul>
        <li><a href="#PORTABILITY1">PORTABILITY1</a>
        <li><a href="#PORTABILITY2">PORTABILITY2</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#PORTABILITY3">PORTABILITY3</a>
        <li><a href="#PORTABILITY4">PORTABILITY4</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#PORTABILITY5">PORTABILITY5</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#SECURITY1">SECURITY1</a>
        <li><a href="#SECURITY2">SECURITY2</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#JNI1">JNI1</a>
        <li><a href="#JNI2">JNI2</a>
      </ul>
    </td>
  <tr>
</table>
</p>
<p>
<h2>Concurrency</h2>

</p>
<p>
<table class="borderless">
  <tr>
    <td valign="top">
      <ul>
        <li><a href="#CONCURRENCY1">CONCURRENCY1</a>
        <li><a href="#CONCURRENCY2">CONCURRENCY2</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#CONCURRENCY3">CONCURRENCY3</a>
        <li><a href="#CONCURRENCY4">CONCURRENCY4</a>
      </ul>
    </td>
    <td valign="top">
      <ul>
        <li><a href="#CONCURRENCY5">CONCURRENCY5</a>
      </ul>
    </td>
  <tr>
</table>
</p>
<p>
<hr />

</p>
<p>
These checks are provided with every installation of BEAM.
With every check is associated a <span class="term">complaint</span> that will be issued
when the conditions for the check are met. (We sometimes use the words "check"
and "complaint" interchangeably.)
</p>
<p>
Every check has parameters that can be used to fine-tune the conditions
under which BEAM will issue a complaint. There are parameters that are
<a href="parms.html#common_parms">common to all checks</a> and some that
are specific to a particular check. As an example all checks support
a parameter <span class="var">enabling_policy</span> like this:
</p>
<pre class="example">
set beam::ERROR1::enabling_policy &quot;always&quot;
set beam::ERROR3::enabling_policy &quot;&quot;
</pre>
<p>

Here, <span class="code">ERROR1</span> is enabled, whereas <span class="code">ERROR3</span> is disabled.
</p>
<p>
In the following detailed description of all checks we will list only 
those parameters that are either specific to the check or where a common
parameter can have check specific values. All other parameters are
described in a <a href="parms.html">separate document</a>.
</p>
<p>
The checks are categorized into ERRORs, MISTAKEs, WARNINGs, SECURITY,
PORTABILITY, and CONCURRENCY so as to help you decide which to turn on.
(If you are wondering how to turn something on or off, look 
at the file <span class="file">tcl/beam_default_parms.tcl</span> in your installation.
That file shows examples of possible settings for all parameters.)
</p>
<p>
You should consider PORTABILITY checks
if you are concerned about porting your code from machines
of one width (like 32-bit machines) to machines of another
width (like 64-bit machines).
</p>
<p>
In contrast, an ERROR is something we expect everybody to want to see,
while WARNINGs very few of you will turn on.
MISTAKEs are somewhere between ERRORs and WARNINGs. Depending on your 
coding style they may be symptoms of something serious of not.
</p>
<p>
You may not like this particular categorization.
For example, while ERROR10 indicates something unintended,
it will probably not cause your program to crash.
Say, you do want ERROR10 reported, but you consider it less serious than ERROR1
(uninitialized variable).
In that case you can set ERROR10's severity differently from ERROR1's severity.
The severity is printed with every complaint and you can then manage the report
based on that.
</p>
<p>
<!--
</p>
<p>
Note:
</p>
<p>
  Before and after these html descriptions are some "magic comments"
 that are used to pull snippets out of this file, and put them in
 another file that's used by the emacs interface to display the
 same "snippets" to the emacs user.
</p>
<p>
  These tags, when found inside an html comment, will delimit a
 snippet. A script that parses this file will take the text between
 them, convert the html to plain text (it understand a few tags,
 and will erase the rest), and write the plain text result out
 to a file that emacs will read in later.
</p>
<p>
  Here are the tags:
</p>
<p>
    <!snippet "STRING"!>
</p>
<p>
    <!/snippet!>
</p>
<p>
  (Do this without exclamation points, only use single < and >.
   I used ! here so that they wouldn't be picked up by the script,
   because that's not a real snippet. See below for examples.)
</p>
<p>
  Between them, place things that you want to show up in
 emacs. Multiple snippets with the same tag will be concatenated
 together in the order they appear in this file to make one snippet
 in the output file.
</p>
<p>
  The script that parses this file is beam/X.X/develop/beam_parse_snippets
</p>
<p>
-->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR1"> -->
<a name="ERROR1"></a><h1>ERROR1: Variable xyz is used, but never assigned</h1>


<h1>ERROR1: Uninitialized xyz</h1>

The value of <span class="var">xyz</span> is used although it was not assigned.
In such a situation <span class="var">xyz</span> evaluates to some random bit string, 
which is rarely desired.
</p>
<p>
This complaint can be issued with either of the two wordings.
The first wording is used if there is 
not a single assignment to <span class="var">xyz</span> anywhere in the function.
The second wording is used even if there are some assignments to <span class="var">xyz</span>,
but there exists a feasible path to the usage of <span class="var">xyz</span>, by-passing 
all assignments. If so, the path is displayed.
</p>
<p>
If you get this complaint please try to avoid the temptation
of simply initializing the variable even if you think that it is unnecessary.
In our experience the majority of uninitialized variables are not 
caused by lack of initialization at the declaration,
but rather by some mistake along the identified path.
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR1::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::ERROR1::enabling_policy</span>
 <td><span class="val">&quot;allow_partially_initialized_records&quot;</span>
 <td>Complaint will be issued for uninitialized variables,
 but not for uninitialized subfields of a structure.
</tr>
<tr>
 <td><span class="var">beam::ERROR1::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
Example:
</p>
<pre class="example">
int ival;

void func()
{
  struct foo {
    int x;
    int y;
  } v1, v2;

  v1.x = 42;
  v2   = v1;    /* no complaint if   enabling_policy = allow_partially_initialized_records */
  func2(v1);    /* no complaint if   enabling_policy = allow_partially_initialized_records */
  ival = v1.y;  /* complaint even if enabling_policy = allow_partially_initialized_records */
}
</pre>
<p>

If <span class="var">enabling_policy</span> is <span class="val">always</span>
then all three commented statements are subject to complaint.
But if <span class="var">enabling_policy</span> is <span class="val">allow_partially_initialized_records</span>
then only the last statement are subject to complain.
</p>
<p>
If you actually try it, you will see that BEAM complains only about the first occurrence
of an uninitialized field. 
That is a general policy designed to minimize the number of complaints and therefore
we used the strange phrase "subject to complain" above.
</p>
<p>
It can happen that only a piece of a variable is initialized, and the remainder is not.
For example, look at this C example:
</p>
<pre class="example">
int func()
{
  union {
    int i;
    short s[2];
  } x;
  x.s[0] = 0;
  return x.i;
}
</pre>
<p>

In that case the message will be:
</p>
<p>
<pre class="example">
uninitialized `x.i[16:31]'
</pre>

</p>
<p>
The notation <span class="code">[16:31]</span> refers to bit positions inside <span class="code">x.i</span>.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR2"> -->
<a name="ERROR2"></a><h1>ERROR2: Invalid operation involving NULL pointer</h1>


</p>
<p>
Example 1:
</p>
<pre class="example">
a = &amp;(p-&gt;f);
b = &amp;(q[2]);
c = r + 2;
</pre>
<p>

The C standard considers these invalid in case <span class="var">p</span>,
<span class="var">q</span>, or <span class="var">r</span> is the NULL pointer.
</p>
<p>
This complaint is suppressed in case of explicitly writing 
</p>
<pre class="example">
a = &amp;(NULL-&gt;f);
</pre>
<p>

because that is a common way of calculating the offset of the field <span class="var">f</span>
(typically via the offsetof macro).
</p>
<p>
Example 2:
</p>
<pre class="example">
i = p-&gt;f;
j = *p;
</pre>
<p>

In case <span class="var">p</span> is NULL the assignment to <span class="var">j</span> involves dereferencing NULL pointer,
which will be reported as ERROR5.
In fact ERROR2 is closely related to dereferencing of NULL pointer, but it is not the same thing.
Consider the above assignment to <span class="var">i</span>, and suppose that the field <span class="var">f</span> 
is at offset 4.
If <span class="var">p</span> is NULL then <span class="code">p-&gt;f</span> does not constitute dereferencing NULL (i.e., address 0)
but dereferencing the address 4.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR3"> -->
<a name="ERROR3"></a><h1>ERROR3: Deallocating an already deallocated contents of xyz</h1>


This complaint is followed by a path though the program.
This paths ends in a deallocation, such as <span class="code">free(<span class="var">xyz</span>)</span>.
Somewhere along that path there is another deallocation of
<span class="var">xyz</span>.
</p>
<p>
Deallocating a memory location more than once can lead to memory
corruption and random crashes much later in the program.
</p>
<p>
Common causes include using two pointers to the same memory instead
of making a copy of an object, or falling through an unexpected
path of code where a second deallocation is occurring.
</p>
<p>
Take a look at where the memory was allocated, and see if there
is any reason that there is more than one place that the memory
can be deallocated. There should be a one-to-one correspondence
between allocations and deallocations for each pointer.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR4"> -->
<a name="ERROR4"></a><h1>ERROR4: Accessing an already deallocated xyz</h1>


This complaint is followed by a path though the program.
This paths ends in an access to a memory location <span class="var">xyz</span>;
this could be an assignment or use of the value of <span class="var">xyz</span>.
But somewhere along that path the location <span class="var">xyz</span> was
previously deallocated. Once memory is deallocated, its value is
undefined, and should not be used.
</p>
<p>
This is commonly caused by having more than one pointer to a
memory location, and deallocating the memory through one of them.
All of the other pointers will still contain the correct address,
but the value at that address will be non-deterministic, and should
never be used.
</p>
<p>
Some things to look at include where the memory is being used and
why it is possible to get to that point after the memory has been
deallocated.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR5"> -->
<a name="ERROR5"></a><h1>ERROR5: Dereferencing NULL pointer</h1>


This complaint is followed by a path though the program.
This paths ends in dereferencing of a pointer, e.g. <span class="code">*xyz</span>.
When dereferenced, <span class="var">xyz</span> will be <span class="code">NULL</span>, which is a problem
because dereferencing a <span class="code">NULL</span> pointer is likely to cause a crash.
There are two ways the path might cause <span class="var">xyz</span> to be considered <span class="code">NULL</span> --
by an assignment, for example 
</p>
<pre class="example">
xyz = NULL;
</pre>
<p>

or by a test, for example,
</p>
<pre class="example">
if ( xyz )
</pre>
<p>

Any path that follows the else branch of such a test
implies that <span class="var">xyz</span> is <span class="code">NULL</span>.
</p>
<p>
Common causes include forgetting to check if a pointer
is <span class="code">NULL</span> before using it, or moving through a path of
code where the pointer is expected to be valid, but is
<span class="code">NULL</span> instead.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR6"> -->
<a name="ERROR6"></a><h1>ERROR6: Invoking a method with a NULL class pointer</h1>


This complaint is followed by a path though the program.
This paths ends in an expression of the form  <span class="code">xyz-&gt;foo()</span>.
When dereferenced, <span class="var">xyz</span> will be <span class="code">NULL</span>, which is a problem
because calling a method via a <span class="code">NULL</span> class pointer is very
dangerous, and will not work in many cases. There are two ways the
path might cause <span class="var">xyz</span> to be considered <span class="code">NULL</span>
-- by an assignment, for example 
</p>
<pre class="example">
xyz = NULL;
</pre>
<p>

or by a test, for example,
</p>
<pre class="example">
if ( xyz )
</pre>
<p>

Any path that follows the else branch of such a test
implies that <span class="var">xyz</span> is <span class="code">NULL</span>.
</p>
<p>
Common causes include forgetting to check if a pointer
is <span class="code">NULL</span> before using it, or moving through a path of
code where the pointer is expected to be valid, but is
<span class="code">NULL</span> instead.
<!-- </snippet> -->
</p>
<p>
The difference between ERROR5 and ERROR6 lies in the fact that ERROR6 refers to
the special case of invoking of a class member <span class="var">foo</span> through a pointer <span class="var">xyz</span>.
This may not automatically lead to a failure, provided the method <span class="var">foo</span>
handles the possibility that <span class="var">this</span> is <span class="code">NULL</span>.
Allowing <span class="var">this</span> to be  <span class="code">NULL</span> is rather dangerous, 
(e.g. it would fail for virtual functions),
but some people consider it OK.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR7"> -->
<a name="ERROR7"></a><h1>ERROR7: Accessing beyond allocated memory</h1>


<h1>ERROR7: Accessing beyond array bounds</h1>

This complaint is followed by a path though the program.
This paths ends in one of 
<ul>
<li>dereferencing a pointer, e.g. <span class="code">*xyz</span>
<li>subscripting an array, e.g. <span class="code">A[I]</span> (which is the same as <span class="code">*(A+I)</span>)
<li>calling a function accessing a buffer, e.g. <span class="code">strcpy(A, B)</span>
</ul>
</p>
<p>
Reading from memory outside of an array's bounds may result
in a random value. Writing into memory outside of an array's
bounds may result in memory corruption.
</p>
<p>
Common causes include not checking a variable's value before
using it to index an array, or using a value that is the 
same as the number of array elements (which is too large to
actually index the array with).
A common cause of buffer overflow is forgetting about terminating null character.
</p>
<p>
Look at the index being used - if it is a variable, make sure
it can only contain values that are within the array's bounds.
If it is not a variable, ensure the declaration of the array
is large enough, and ensure that the index is correct.
<!-- </snippet> -->
</p>
<p>
BEAM assumes a memory model where all allocations (on heap as well as stack) are independent of each other.
It may issue ERROR7 if you are assuming allocations are not independent,
such as assuming that memory is allocated consecutively.
</p>
<p>
The value of <span class="var">enabling_policy</span> is a <a href="parms.html#patterns">pattern</a>,
whose terms are "negative_bound", "lower_bound", "upper_bound" and "array_bound".
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR7::enabling_policy</span>
 <td><span class="val">&quot;negative_bound&quot;</span>
 <td>Complaint will be issued when accessing an address lower than the beginning of the allocated memory.
</tr>
<tr>
 <td><span class="var">beam::ERROR7::enabling_policy</span>
 <td><span class="val">&quot;lower_bound&quot;</span>
 <td>Same as negative_bound, but in addition complaint will be issued when
accessing an array using negative index, and the position of the array in allocated memory
cannot be determined.
</tr>
<tr>
 <td><span class="var">beam::ERROR7::enabling_policy</span>
 <td><span class="val">&quot;upper_bound&quot;</span>
 <td>Complaint will be issued when accessing an address higher then the end of the allocated memory.
</tr>
<tr>
 <td><span class="var">beam::ERROR7::enabling_policy</span>
 <td><span class="val">&quot;array_bound&quot;</span>
 <td>Complaint will be issued when an array index is outside array bounds.
</tr>
<tr>
 <td><span class="var">beam::ERROR7::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span> 
 <td>Any of the above
</tr>
<tr>
 <td><span class="var">beam::ERROR7::extensible_struct</span>
 <td><span class="val">&quot;yes&quot;</span> 
 <td>array[1] (or array[0]) at the end of struct may be accessed with larger index.
</tr>
<tr>
 <td><span class="var">beam::ERROR7::extensible_struct</span>
 <td><span class="val">&quot;no&quot;</span> 
 <td>array[1] (and array[0]) at the end of struct has no special interpretation.
</tr>
</table>
</p>
<p>
Example 1:
</p>
<pre class="example">
typedef struct {int a; int b[10]; int c;} abc;
void f(int *p)
{
  abc *s = (abc *) malloc(sizeof(abc));
  s-&gt;b[9] = 0;  /* no complaint */
  s-&gt;b[10] = 0; /* complaint if enabled array_bound */
  s-&gt;b[11] = 0; /* complaint if enabled array_bound or upper_bound */
  s-&gt;b[-1] = 0; /* complaint if enabled array_bound */
  s-&gt;b[-2] = 0; /* complaint if enabled array_bound or negative_bound or lower_bound */
  p[-1]    = 0; /* complaint if enabled lower_bound */
}
</pre>
<p>

Please note the difference between <span class="code">s-&gt;b[10]</span> and <span class="code">s-&gt;b[11]</span> in the example.
The latter most likely accesses beyond allocated memory,
while the former does not -- it is likely to access the field <span class="var">b</span>
(depending on how the compiler lays out the struct).
Both are rarely intended, but <span class="code">s.a[11]</span> has two strikes against it,
while <span class="code">s.a[10]</span> has only one.
</p>
<p>
Please note that negative_bound and lower_bound have the same effect if it is clear
where inside allocated memory the array lies.
But if it is not clear, as in the case of the pointer <span class="var">p</span>,
then lower_bound may allow the complaint,
while negative_bound will not.
</p>
<p>
Example 2:
</p>
<pre class="example">
extern struct {int a; int b[1];} *s;
s-&gt;a[10] = 0;
</pre>
<p>

There is a common C programming trick where a variable is declared like
<span class="var">s</span> above. 
(Alternatively, <span class="var">b</span> could be declared as <span class="code">b[0]</span> or <span class="code">b[]</span>.)
If the memory allocated for <span class="var">s</span> is larger than the size of 
the struct as declared, then <span class="code">s-&gt;a[10]</span>
may not exceed allocated memory, although it exceeds the declared size of the array.
The parameter <span class="var">extensible_struct</span> tells BEAM whether you mean to 
use such a trick.
If it is set to "no" then BEAM will issue the usual ERROR7 for <span class="code">s-&gt;a[10]</span>
even if it does not know how much memory is allocated for <span class="var">s</span>.
However, if it is set to "yes" then it will issue ERROR7 only if it is sure 
that not enough memory is allocated.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR8"> -->
<a name="ERROR8"></a><h1>ERROR8: Passing pointer to deallocated memory</h1>


This complaint is followed by a path though the program.
This paths ends in the use of some variable <span class="var">xyz</span>,
which is a pointer previously freed along the path.
For example,
</p>
<pre class="example">
free ( xyz );
a = xyz;
foo ( xyz );
if (xyz) ...
b = (xyz == another_ptr) ? c : d;
</pre>
<p>

The reason for the complaint is that normally nobody wants a dangling pointer to 
deallocated memory. Using a pointer to deallocated memory is dangerous because
it is usually unknown whether or not it will be dereferenced in the future.
The only possibly exception is comparing the value of a deallocated pointer
to some other pointer.
In the above example the if-statement compares <span class="var">xyz</span> against <span class="code">NULL</span>
and in the assignment to <span class="var">b</span> there is a comparison of 
<span class="var">xyz</span> against <span class="var">another_ptr</span>.
In contrast, the assignment to <span class="var">a</span> and the call to <span class="function">foo</span>
does not involve any comparison.
Setting of <span class="var">enabling_policy</span> allows you to specify whether you 
allow comparison of deallocated pointers.
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR8::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::ERROR8::enabling_policy</span>
 <td><span class="val">&quot;compared&quot;</span>
 <td>Complaint will be issued only if the deallocated pointer
is being compared with another pointer.
</tr>
<tr>
 <td><span class="var">beam::ERROR8::enabling_policy</span>
 <td><span class="val">&quot;not_compared&quot;</span>
 <td>Complaint will be issued only if the deallocated pointer
is not being compared with another pointer.
</tr>
</table>
</p>
<p>
Common causes include meaning to use the pointer before it
is deallocated, or meaning to set the pointer to <span class="code">NULL</span> or
to new memory before it is used again after the deallocation.
</p>
<p>
Things to look at include where the memory is deallocated,
and the path of code up until it is first used again. Most
of the time, the pointer should be reassigned to <span class="code">NULL</span> or
another memory location before it is used again.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR9"> -->
<a name="ERROR9"></a><h1>ERROR9: Passing NULL</h1>


This complaint is followed by a path though the program.
The paths ends in a function call like
</p>
<pre class="example">
f ( xyz );
</pre>
<p>

At that point <span class="var">xyz</span> will be <span class="code">NULL</span>, which is a problem
because <span class="function">f</span> is incapable of handling a <span class="code">NULL</span> pointer.
</p>
<p>
Passing <span class="code">NULL</span> to certain functions will result in undefined behavior.
</p>
<p>
Common causes include forgetting to check whether a pointer is <span class="code">NULL</span>
before passing it to a function, using the wrong function, or assuming
that the function allows <span class="code">NULL</span> pointers as arguments.
</p>
<p>
Look at the argument that is being passed into the function, and 
look back at its declaration or definition. Decide if you should be
checking its value against <span class="code">NULL</span> before using it in the function call.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR10"> -->
<a name="ERROR10"></a><h1>ERROR10: Function with variable number of arguments is being passed non-POD structure xyz</h1>


Passing an object of non-POD class type to a variable argument list is undefined
in C++. This complaint does nothing for C.
</p>
<p>
Here is an example that BEAM has encountered on several occasions:
</p>
<pre class="example">
class yasc { // Yet Another String Class
  private:
  const char *name;
  size_t      len;

  public:
  const char *c_str() { return name; }
  // more stuff
};

yasc answer = &quot;42&quot;;

printf(&quot;.. and the answer is '%s'\n&quot;, answer); // <span class="strong">should be</span> answer.c_str()
</pre>
<p>

This code works by accident because the data layout of the class happens 
to allocate <span class="var">name</span> at offset zero. It will break in mysterious ways
if <span class="var">name</span> gets assigned a different offset, e.g. by changing the
order of the data members, by defining virtual functions, or by
modifying the class's inheritance.
</p>
<p>
Passing a non-POD structure to a variable-argument function is undefined
according to the C++ Standard, section 5.2.2, paragraph 7. For some
compilers, there may be an abort at runtime. For others, anything can
happen.
</p>
<p>
Common causes include passing a structure when you meant to pass the
structure's address or one of the structure's members, using the wrong
variable, using a variable with the wrong type, or calling the wrong
function.
</p>
<p>
Look at the function's definition to see why it expects a variable
number of arguments, and then look at the variable's declaration
to see what its type is. Variable-argument functions should usually
only be passed "scalar" types (built-in types, pointers, etc).
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR11"> -->
<a name="ERROR11"></a><h1>ERROR11(resource): Leaving a function with a pointer to deallocated resource</h1>


Because the resource (e.g. memory) is not going to exist after the function returns,
making a pointer to that resource available from outside the function
is usually an error, and dereferencing that pointer will result in
a random value.
</p>
<p>
Example 1:
</p>
<pre class="example">
char *bar(void)
{
  char foo[100];
  ...
  return foo;
}
</pre>
<p>

The array <span class="var">foo</span> is allocated on the stack and will be deallocated just as 
the function returns, causing a pointer to deallocated memory to be returned.
</p>
<p>
Example 2:
</p>
<pre class="example">
void bar(void)
{
  static int *foo;
  ...
  free ( foo );
}
</pre>
<p>

This will leave <span class="var">foo</span> pointing to deallocated memory, which 
may be a problem if <span class="var">foo</span> is accessed later.
It is generally recommended to code it like this 
</p>
<pre class="example">
void bar(void)
{
  static int *foo;
  ...
  free ( foo );
  foo = NULL;
}
</pre>
<p>

This way, testing <span class="code">(foo == NULL)</span> can be used to determine whether
<span class="var">foo</span> contains a valid pointer or not.
</p>
<p>
In Example 1 the deallocated memory was exposed via return,
in Example 2 it was via a static variable.
In general this complaint is issued if a resource is allocated and then 
deallocated in a function, and a pointer to the resource is made accessible
after a return from the function.
There are 6 ways of exposing deallocated memory, all illustrated in the
following example
</p>
<pre class="example">
extern char *Extern;
static char *Static_File;
static char **Heap;

char *foo(char **Parameter, int a)
{
  static char *Static_Local;
  char Local[10];  
  
  Heap = (char **) malloc(sizeof(char *));  
  
  switch(a)
    {
     case 1: *Heap        = Local; break;
     case 2: *Parameter   = Local; break;
     case 3: Extern       = Local; break;
     case 4: Static_Local = Local; break;
     case 5: Static_File  = Local; break;
     case 6: return         Local;
     }
  return 0;
}
</pre>
<p>

Common causes include forgetting to allocate the memory in a more
permanent fashion (on the heap, for example), using the wrong
address, or using a pointer instead of the dereferenced type.
</p>
<p>
Examine where the external address of the temporary memory is being
assigned, and decide if it should remain a pointer or not. If so,
you must change the memory that is pointed to so that it will remain
after the function returns. If not, then you should change the type
of the external assignment so that it is no longer a pointer to
temporary memory.
<!-- </snippet> -->
</p>
<p>
The user may not consider all 6 ways equally serious.
Using <span class="var">beam::ERROR11::enabling_policy</span> he can control which he wants to have reported.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;heap&quot;</span>
 <td>Complaint will be issued if the deallocated memory is exposed via another
     memory allocated inside the function on the heap (case 1 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;parameter&quot;</span> 
 <td>Complaint will be issued if the deallocated memory is exposed 
     by assigning through a parameter (case 2 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;extern&quot;</span> 
 <td>Complaint will be issued if the deallocated memory is exposed 
     by assigning it to an extern variable (case 3 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;static-local&quot;</span>
 <td>Complaint will be issued if the deallocated memory is exposed 
     by assigning it to a variable declared static inside the 
     function (case 4 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;static-file&quot;</span>
 <td>Complaint will be issued if the deallocated memory is exposed 
     by assigning it to a variable declared static outside any 
     function (case 5 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;return&quot;</span>
 <td>Complaint will be issued if the deallocated memory is exposed via 
     return (case 6 above)
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued in any of the above cases
</tr>
<tr>
 <td><span class="var">beam::ERROR11::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
The value of <span class="var">enabling_policy</span> can be a list of the above terms;
any term that is on the list will apply.
E.g. 
</p>
<pre class="example">
set beam::ERROR11::enabling_policy &quot;return parameter&quot;
</pre>
<p>

The setting will cause a complaint in case the deallocated memory
is passed out via a return statement or via a parameter.
</p>
<p>
There is a different set of parameters (e.g. <span class="var">enabling_policy</span>)
for each resource (e.g., <span class="val">heap_memory</span>, <span class="val">stack_memory</span>).
If a parameter for a resource is is not set then it defaults to the value
of the parameter for the null resource.
For example, consider the following settings 
(which have the same effect independently of their order)
</p>
<pre class="example">
set beam::ERROR11(heap_memory)::enabling_policy  &quot;return&quot;
set beam::ERROR11(stack_memory)::enabling_policy &quot;always&quot;
set beam::ERROR11(file)::enabling_policy         &quot;parameter&quot;
set beam::ERROR11::enabling_policy               &quot;extern&quot;
</pre>
<p>

This will cause a complaint about: 
</p>
<p>
<ul>
 <li>dangling pointers to heap memory returned from a function
 <li>any dangling pointers to stack memory
 <li>closed files assigned through a parameter
 <li>dangling pointers to all other resources assigned to external variables
</ul>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR12"> -->
<a name="ERROR12"></a><h1>ERROR12: Memory leak</h1>


This complaint has been replaced by ERROR23(heap_memory).
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR13"> -->
<a name="ERROR13"></a><h1>ERROR13: printf argument xyz of
type type is being passed to the underlined</h1>


</p>
<p>
Example:
</p>
<pre class="example">
int xyz;
...
printf(&quot;beginning of pattern %s rest of pattern&quot;, xyz);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
printf argument 'xyz' of type 'int' is being passed to the underlined
beginning of pattern %s rest of pattern
                     ^^
</pre>
<p>

Passing the wrong type to a format string will result in the type
being converted incorrectly, which will result in garbage values in
the final string.
</p>
<p>
Common causes include missing a format specification or an argument,
which leaves the arguments mismatched with the specifications, or
passing the wrong variable or value.
</p>
<p>
Look at the format pattern and ensure that the parameter's type
matches what the format pattern expects.
<!-- </snippet> -->
</p>
<p>
In general, the following rules are assumed
</p>
<p>
<table>
<tr>
 <th>Pattern</th>
 <th>Matches</th>
</tr>
<tr>
 <td><span class="code">%c</span></td>
 <td><span class="code">char</span></td>
</tr>
<tr>
 <td><span class="code">%C</span></td>
 <td><span class="code">wchar_t</span></td>
</tr>
<tr>
 <td><span class="code">%d</span></td>
 <td><span class="code">char</span>, <span class="code">short</span>, <span class="code">int</span>, 
     <span class="code">bool</span>, and enumerated types</td>
</tr>
<tr>
 <td><span class="code">%i</span></td>
 <td><span class="code">char</span>, <span class="code">short</span>, <span class="code">int</span>, 
     <span class="code">bool</span>, and enumerated types</td>
</tr>
<tr>
 <td><span class="code">%o</span></td>
 <td><span class="code">char</span>, <span class="code">short</span>, <span class="code">int</span>, 
     <span class="code">bool</span>, and enumerated types</td>
</tr>
<tr>
 <td><span class="code">%u</span></td>
 <td><span class="code">char</span>, <span class="code">short</span>, <span class="code">int</span>, 
     <span class="code">bool</span>, and enumerated types</td>
</tr>
<tr>
 <td><span class="code">%e</span></td>
 <td><span class="code">float</span>, <span class="code">double</span>, and <span class="code">long double</span></td>
</tr>
<tr>
 <td><span class="code">%E</span></td>
 <td><span class="code">float</span>, <span class="code">double</span>, and <span class="code">long double</span></td>
</tr>
<tr>
 <td><span class="code">%f</span></td>
 <td><span class="code">float</span>, <span class="code">double</span>, and <span class="code">long double</span></td>
</tr>
<tr>
 <td><span class="code">%g</span></td>
 <td><span class="code">float</span>, <span class="code">double</span>, and <span class="code">long double</span></td>
</tr>
<tr>
 <td><span class="code">%G</span></td>
 <td><span class="code">float</span>, <span class="code">double</span>, and <span class="code">long double</span></td>
</tr>
<tr>
 <td><span class="code">%s</span></td>
 <td>pointer to <span class="code">char</span></td>
</tr>
<tr>
 <td><span class="code">%S</span></td>
 <td>pointer to <span class="code">wchar_t</span></td>
</tr>
<tr>
 <td><span class="code">%p</span></td>
 <td>anything</td>
</tr>
<tr>
 <td><span class="code">%x</span></td>
 <td>anything</td>
</tr>
<tr>
 <td><span class="code">%X</span></td>
 <td>anything</td>
</tr>
</table>
</p>
<p>
In addition, anything matches <span class="code">void*</span>.
</p>
<p>
The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for incorrect format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR14"> -->
<a name="ERROR14"></a><h1>ERROR14: No printf argument to match the underlined</h1>


</p>
<p>
Example:
</p>
<pre class="example">
printf(&quot;beginning of pattern %s rest of pattern&quot;);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
No printf argument to match the underlined
beginning of pattern %s rest of pattern
                     ^^
</pre>
<p>

When there aren't enough arguments to match all of the format
specifications, the function will begin reading uninitialized
stack values to fill their places. This will result in random
values in the final string.
</p>
<p>
Common causes include forgetting to pass enough parameters to
the format pattern, or forgetting to remove the specification
from the format pattern, if it is no longer needed.
</p>
<p>
Ensure that the number of format specifications is the same as
the number of parameters being passed to it.
</p>
<p>
The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for incorrect format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR15"> -->
<a name="ERROR15"></a><h1>ERROR15: Argument xyz not used in the printf pattern pattern</h1>


</p>
<p>
Example:
</p>
<pre class="example">
printf(&quot;pat&quot;, xyz);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
Argument `xyz' not used in the printf pattern
pat
</pre>
<p>

When there are too many parameters to a format pattern, the
format pattern will simply ignore the rest. This won't cause
any undefined behavior, but will result in values not being
added to the final string.
</p>
<p>
The problem is much more serious if the pattern uses the notation 
<span class="code">%5$d</span> (instead of %d).
That allows the possibility that an argument in the middle is not used
resulting in unpredictable behavior.
</p>
<p>
Common causes include forgetting to add the specification to
the pattern, or passing too many parameters to the function.
</p>
<p>
Ensure that the number of format specifications is the same as
the number of parameters being passed to it.
</p>
<p>
The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for incorrect format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR16"> -->
<a name="ERROR16"></a><h1>ERROR16: The underlined is an invalid printf conversion specification</h1>


</p>
<p>
Example:
</p>
<pre class="example">
printf(&quot;beginning of pattern %l rest of pattern&quot;, xyz);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
The underlined is an invalid printf conversion specification
beginning of pattern %l rest of pattern
                     ^^
</pre>
<p>

In the example, it should probably be <span class="code">%ld</span>.
</p>
<p>
The format pattern contains a conversion specification that is
unknown. This will usually cause the rest of the arguments to
be off-by-one since the parameter for this specification will
not be used here.
</p>
<p>
Common causes include using the wrong conversion specifier
(writing "%l" when you meant "%ld" for example), or writing
a single percent sign to represent a literal percent sign in 
the output (which must be written as "%%" in the format pattern).
</p>
<p>
Look at the format specification and decide what you meant for
it to be. Either change it so that it is a valid conversion
specification or remove it from the format string. Also ensure
that the arguments are still correct, given the new format string.
</p>
<p>
The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for incorrect format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR17"> -->
<a name="ERROR17"></a><h1>ERROR17: scanf argument xyz needs to be a pointer</h1>


</p>
<p>
Example:
</p>
<pre class="example">
int xyz;
scanf(&quot;%d&quot;, xyz);
</pre>
<p>

should probably be
</p>
<pre class="example">
int xyz;
scanf(&quot;%d&quot;, &amp;xyz);
</pre>
<p>

Since scanf dereferences its arguments as pointers, they must all
be pointers. Passing anything else will usually lead to undefined
behavior since scanf will treat the value as an address and attempt
to write to that memory.
</p>
<p>
Common causes include forgetting to take the address of a variable
instead of using the variable itself, passing the wrong variable,
or passing a variable of the wrong type.
</p>
<p>
Ensure that all of scanf's arguments are pointers to valid memory.
</p>
<p>
The function <span class="function">scanf</span> is not the only one whose arguments will be checked.
BEAM will check any function's arguments,
provided that function is given a format 
<a href="attributes.html">attribute</a> with <span class="code">kind=scanf</span>.
For an example, see the usage of  <span class="var">scanf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR18"> -->
<a name="ERROR18"></a><h1>ERROR18: Function foo lacks a return statement with a value</h1>


The named function was declared to return a value. However, there
is a path through the function along which no value is returned.
This can happen for instance if control flow reaches the end of the function
without encountering a return statement. E.g.
</p>
<pre class="example">
int foo()
{
   if (a != 0) return 10;
   --a;
}              &lt;-- complaint
</pre>
<p>

In this situation the compiler will arrange for a return statement under the 
covers but it will not return any value. Hence, a random value is returned to
the caller.
</p>
<p>
ERROR18 is also issued for explicit return statements that do not return
anything as in this example:
</p>
<pre class="example">
int foo()
{
   if (a != 0) return;         &lt;-- complaint
   --a;
   return 10;
}
</pre>
<p>

This error is also often found in functions that have no declared return type.
The compiler then assumes an implicit return type of <span class="code">int</span> 
not <span class="code">void</span>.
</p>
<p>
Look at the path through the function and decide where a return
statement should go, and what should be returned.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR19"> -->
<a name="ERROR19"></a><h1>ERROR19: Statement always fails</h1>


This is a statement (typically an assignment) that is normally not meant to fail,
yet it always causes some runtime error.
</p>
<p>
Example:
</p>
<pre class="example">
#define M(x)   x == 0 ? 10   :   x == 1 ? 20   :   (abort(), 0)
y = M(2);
</pre>
<p>

Causes of failure include the functions <span class="function">abort</span>, <span class="function">fail</span>,
as well as several project specific functions.
</p>
<p>
Look at the statement and decide why it will always fail. For some
reason, all possible paths lead to failure, which is rarely desired.
Figure out which path(s) should not have led to failure, and make
the appropriate change.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR20"> -->
<a name="ERROR20"></a><h1>ERROR20: Return with no value, in function returning type</h1>


This complaint is issued for explicitly written return statements that do not
return a value, although the containing function has a non-void return type.
</p>
<p>
Example:
</p>
<pre class="example">
int foo()
{
  ...
  return;
}
</pre>
<p>

The return statement  specifies no return value, therefore the function 
will return a random value.
</p>
<p>
This error happens often in legacy C/C++ code where functions that do not
return a value were declared without a return type, like so:
</p>
<pre class="example">
foo()
{
  ...
  return;
}
</pre>
<p>

In this case the compiler will give the function an implicit <span class="code">int</span>
return type and not, as might be expected, a <span class="code">void</span> type.
Declaring functions this way is deprecated practice and in C++ it's an 
error nowadays.
Code that uses this old-style declaration should be changed and
use <span class="code">void</span> instead.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR21"> -->
<a name="ERROR21"></a><h1>ERROR21: Argument of function should be a pointer</h1>


</p>
<p>
Example:
</p>
<pre class="example">
struct s {int a; int b:} S;
  ...
free(S);
</pre>
<p>

The function <span class="function">free()</span> expects a pointer.
The above would be a syntax error, if the compiler had a the standard declaration of  <span class="function">free()</span>
as in  <span class="file">stdlib.h</span>.
However, in the absence of a declaration for  <span class="function">free()</span>, this is not a syntax error;
the compiler will assume that the function <span class="function">free</span> takes <span class="code">struct s</span>
as argument.
</p>
<p>
A common cause of this error is typing <span class="code">free(*p)</span>
instead of  <span class="code">free(p)</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR22"> -->
<a name="ERROR22"></a><h1>ERROR22: Division by 0</h1>


Division by 0 typically causes an execution exception.
If BEAM finds that such a possibility exists then it issues ERROR22
and displays an execution path that would lead to the error.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR23"> -->
<a name="ERROR23"></a><h1>ERROR23(resource): Resource leak</h1>


This complaint is followed by a path though the program.
Along this path a resource is obtained
(e.g. memory is allocated, file is opened)
and becomes inaccessible before it can be released 
(e.g. memory is freed, file is closed).
It becomes inaccessible because
variables containing a pointer to the resource
receive new values, or become deallocated themselves.
</p>
<p>
As an example consider a memory leak:
Losing all pointers to allocated memory means that the memory can
never be freed. This memory leak can cause the application to run
out of memory if it happens enough times. If the memory was an
object, its destructor will never be called, which can also lead to
incorrect or missing behavior.
</p>
<p>
Common causes include forgetting to deallocate the memory before 
assigning over the pointer, forgetting to save the pointer
somewhere, or allocating memory when you meant to simply use a
pointer to memory that was already allocated somewhere else.
</p>
<p>
Look at the memory allocation, and watch the pointer. Before it
is assigned over, it should be either deallocated, or stored
somewhere.
<!-- </snippet> -->
</p>
<p>
There is a different set of parameters (e.g. <span class="var">enabling_policy</span>)
for each resource (e.g., <span class="val">heap_memory</span>, <span class="val">file</span>).
If a parameter for a resource is is not set then it defaults to the value
of the parameter for the null resource.
For example, consider the following settings 
(which have the same effect independently of their order)
</p>
<pre class="example">
set beam::ERROR23(heap_memory)::disabling_comment  &quot;memory leak&quot;
set beam::ERROR23(file)::disabling_comment         &quot;file never closed&quot;
set beam::ERROR23::disabling_comment               &quot;resource leak&quot;
</pre>
<p>

An instance of ERROR23 can be disabled by 
</p>
<p>
<ul>
  <li>"memory leak" if it is ERROR23(heap_memory)
  <li>"file never closed" if it is ERROR23(file)
  <li>"resource leak" for all other resources
</ul>
</p>
<p>
Resource leaks in the <span class="function">main()</span> function are not really a problem
because resources will be freed by the operation system upon return from 
<span class="function">main()</span> anyway.
Therefore our default installation contains the setting 
</p>
<pre class="example">
set beam::ERROR23::disabled_functions { main }
</pre>
<p>

In case you do want to be told about resource leaks in the <span class="function">main()</span> function
then you can override the default in your parms Tcl file by 
</p>
<pre class="example">
set beam::ERROR23::disabled_functions &quot;&quot;
</pre>
<p>

The accuracy of resource leak complaints is affected by assumptions about
side-effects of unknown function to an even larger extent than other kinds 
of complaints.
Consider a resource that is allocated in a function, but never deallocated 
in that function.
It may not leak, provided it is passed to another function <span class="function">foo()</span>,
which will
deallocate it, or save it in static memory for deallocation by the calling 
environment.
BEAM can take the effect of <span class="function">foo()</span> into account, provided
it is given its body, or given an <a href="attributes.html">attribute</a>
for <span class="function">foo()</span>.
On the other hand, if BEAM has no information about <span class="function">foo()</span>
then its assumptions about its side-effects may lead to many leaks
unreported, or conversely many false positives.
The user can control assumptions about such unknown functions using
the parameter <span class="var">beam::ERROR23(resource)::unknown_functions_effect</span>,
which says how conservative BEAM should be with all unknown functions.
The value is a <a href="parms.html#patterns">pattern</a>.
If the string <span class="val">saves_parameter</span> matches that pattern 
then BEAM assumes that <span class="code">foo(p)</span> might
save any parameter <span class="var">p</span> in a global variable,
and therefore it suppresses the leak complaint for the given resource.
Otherwise it will issue the complaint, but will identify 
function calls where it made any side-effect assumption.
The effect can be illustrated by the following example
</p>
<pre class="example">
typedef struct {
  int             data;
  pthread_mutex_t mutex;
} structure;

extern void foo(structure *);

void f1()
{
  structure *s = new structure;
  foo(s);
  pthread_mutex_init(&amp;(s-&gt;mutex),0);
}
</pre>
<p>

</p>
<p>
There are two resources that might leak -- the heap memory allocated for 
<span class="var">s</span> and abstract resource <span class="var">lock</span> allocated by 
<span class="function">pthread_mutex_init</span>.
(The existing attributes for <span class="function">pthread_mutex_init</span> declare
that it allocates a resource named <span class="var">lock</span>, so that failure
to call <span class="function">pthread_mutex_destroy</span> will be detected as a resource 
leak.)
The call <span class="code">foo(s)</span> may save its parameter in a static memory
for later deallocation.
In the default BEAM installation there are two settings
</p>
<pre class="example">
set  beam::ERROR23(lock)::unknown_functions_effect &quot;&quot;
set  beam::ERROR23(heap_memory)::unknown_functions_effect &quot;saves_parameter&quot;
</pre>
<p>
They represent the following coding convention:
It is normal to allocate heap memory and pass it to calling environment
for later deallocation.
But that is not normal for <span class="var">lock</span> resources -- a mutex initialized
in a function should be later destroyed in the same function.
With this default setting BEAM will not report failure to delete s,
but will report failure to destroy the mutex.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR24"> -->
<a name="ERROR24"></a><h1>ERROR24: Failure to close file</h1>


This complaint has been replaced by ERROR23(file).
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR25"> -->
<a name="ERROR25"></a><h1>ERROR25: uninitialized member xyz</h1>


This complaint should be turned on if you intend constructors
to initialize all class members.
The complaint will be issued if there is a path through a constructor
along which a member is not initialized.
</p>
<p>
The same kind of conservatism applies here as for uninitialized 
variables in general.
In particular, this complaint will be suppressed if the constructor
calls a method, whose side-effects BEAM does not understand, because
that method might do all the initializations.
<!-- </snippet> -->
</p>
<p>
Setting of enabling_policy allows you to avoid getting ERROR25
in case the constructor exists by throwing an exception.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR25::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::ERROR25::enabling_policy</span>
 <td><span class="val">&quot;exception&quot;</span>
 <td>Complaint will be issued only if the constructor throws an exception,
does not catch it, and in that situation fails to initialize a member.
</tr>
<tr>
 <td><span class="var">beam::ERROR25::enabling_policy</span>
 <td><span class="val">&quot;mainline&quot;</span>
 <td>Complaint will be issued only if the constructor fails the initialize 
a member without throwing an uncaught exception.
</tr>
<tr>
 <td><span class="var">beam::ERROR25::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR26"> -->
<a name="ERROR26"></a><h1>ERROR26(property): xyz is not v</h1>


</p>
<p>
Example 1:
</p>
<pre class="example">
a = new int;
free(a);
</pre>
<p>

For this code BEAM would generate the following complaint
</p>
<pre class="example">
-- ERROR26(memory allocation source)     /*wrong deallocator*/     &gt;&gt;&gt;ERROR26_f_a19412af0a39ba
&quot;p.C&quot;, line 11: `a' is not `from malloc'
ONE POSSIBLE PATH LEADING TO THE ERROR:
 &quot;p.C&quot;, line 10: `operator new' generates a value that is `from new'
 &quot;p.C&quot;, line 11: `free' requires its argument to be `from malloc'
</pre>
<p>

When memory is allocated via one mechanism, it needs to be freed via
the matching mechanism. This is because each mechanism (malloc/free,
new/delete, etc) allocates and deallocates memory in a certain way,
which might be drastically different from the others. Using the wrong
one can lead to anything from a memory leak to incorrect behavior or
corrupt memory. 
</p>
<p>
BEAM knows about this rule of pairing allocators and deallocators because
they have been assigned certain values of the property "memory allocation source".
Properties can be assigned to functions using <a href="attributes.html">attributes</a>.
</p>
<p>
Besides allocators and deallocators, other properties might have been 
assigned by yourself or somebody on tour team.
For example, you can have a property "sortedness";
a function <span class="function">sort</span> might declare its output to have the value "sorted",
and a function <span class="function">binary_search</span> might require its input to have the value "sorted".
Another example would be a property "security"; 
the function <span class="function">fgets</span> might declare its output to have the value "not_trusted",
and a function <span class="function">system</span> might require its input to have the value "trusted".
</p>
<p>
The following pairings are provided with BEAM installation:
</p>
<p>
<table>
<tr>
 <th align=left>Property
 <th align=left>Value
 <th align=left>Provided by
 <th align=left>Required by
</tr>
<tr>
 <td rowspan="3">memory allocation source</td>
 <td>from malloc</td>
 <td>malloc<br>calloc<br>realloc<br>mlalloc<br>clalloc<br>relalloc</td>
 <td>free<br>realloc<br>relalloc</td>
</tr>
<tr>
 <td>from new</td>
 <td>new<br>new (nothrow)</td>
 <td>delete<br>delete (nothrow)</td>
</tr>
<tr>
 <td>from new array</td>
 <td>new []<br>new [] (nothrow)</td>
 <td>delete []<br>delete [] (nothrow)</td>
</tr>
<tr>
 <td rowspan="1">file source</td>
 <td>from fopen</td>
 <td>fopen</td>
 <td>fclose</td>
</tr>
</table>
<!-- </snippet> -->
</p>
<p>
ERROR26 is parametrized by the name of the property violated,
provided the property does have a name.
That allows you to control which properties you care about.
For example, 
</p>
<pre class="example">
set &quot;beam::ERROR26(java.util.Iterator state)::disabled_files&quot;   &quot;*/xyz_dir/*&quot;
set  beam::ERROR26::disabled_files                              &quot;&quot;
</pre>
<p>
This will have the effect of suppressing ERROR26 concerning any Iterator properties
in all source files under the subdirectory <span class="code">xyz_dir</span>.
But violations of all other properties will be reported everywhere.
</p>
<p>
Please see <a href="force_test.html">the Application Note</a>
for examples on using ERROR26.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR27"> -->
<a name="ERROR27"></a><h1>ERROR27: Invalid value</h1>


This complaint has been replaced by WARNING6.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR28"> -->
<a name="ERROR28"></a><h1>ERROR28: The arguments to function must be terminated
by NULL</h1>


Some functions that take a variable number of arguments rely on 
a terminating <span class="code">NULL</span>. In this case, a terminating
<span class="code">NULL</span> was not found.
</p>
<p>
Ensure that you meant to call this function that expects
<span class="code">NULL</span> as its last argument, and then terminate the
argument list with <span class="code">NULL</span>.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="val">beam::ERROR28::functions</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">unqualified name</a>
 matches the pattern.
</tr>
<tr>
 <td><span class="val">beam::ERROR28::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="val">beam::ERROR28::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for functions whose
      <a href="func_name_sig.html">signature</a> is
      one in this list.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR29"> -->
<a name="ERROR29"></a><h1>ERROR29: It is not allowed to access printf arguments both randomly and sequentially</h1>


</p>
<p>
Example:
</p>
<pre class="example">
printf(&quot;print arg2 by random access: %2$d, sequential access: %d&quot;, abc, uvw, xyz);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
It is not allowed to access printf arguments both randomly and sequentially
 print arg2 by random access: %2$d, sequential access: %d
                                ^^                     ^^
</pre>
<p>

If a format pattern uses the random method of accessing arguments,
then it must use that method throughout.
Otherwise something undefined will happen.
</p>
<p>
The complaint prints the format pattern and underlines two argument accesses
one random and one sequential indicating the inconsistency.
</p>
<p>
The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for incorrect format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR30"> -->
<a name="ERROR30"></a><h1>ERROR30: Exception type must be caught, or declared by
             this function</h1>


<h1>ERROR30: Calling function may throw type,
      which must be caught, or declared by this function</h1>

An exception may be thrown, either explicitly via <span class="function">throw()</span>,
or implicitly by calling a function which throws exceptions. This
thrown exception is not caught inside the current function, and the
current function isn't allowed to throw it because it isn't declared
in the function's exception specification list.
</p>
<p>
Example:
</p>
<pre class="example">
void foo() throw(int)
{
  ...
  bar(); // declared to throw double
  ...
}
</pre>
<p>

If <span class="function">bar()</span> throws an exception of type <span class="code">double</span>,
then the special C++ function <span class="function">unexpected()</span> will be called
(because <span class="function">foo()</span> can't throw a double). The default action of
<span class="function">unexpected()</span> is to terminate the application.
</p>
<p>
There are two exception types that are treated specially:
<span class="var">std::bad_exception</span> and <span class="var">std::bad_alloc</span>.
</p>
<p>
<span class="var">std::bad_exception</span> is automatically thrown by the special
function <span class="function">unexpected()</span> if an exception reaches a function
which doesn't list it in the exception specification. For this reason,
if BEAM sees a function list <span class="var">std::bad_exception</span> in
its exception specification, BEAM will not complain about
exceptions that aren't listed. BEAM assumes that you expect the
unexpected.
</p>
<p>
<span class="var">std::bad_alloc</span> is thrown by allocators (like <span class="code">operator
new</span>) when there is no more memory. For this reason, BEAM ignores
<span class="var">std::bad_alloc</span> unless the BEAM configuration parameter
<a href="parms.html#beam::allocation_may_return_null">beam::allocation_may_return_null</a>
is set to "yes".
<!-- </snippet> -->
</p>
<p>
When a function declares an empty exception specification, it may not
throw any exceptions. When a function doesn't declare an exception
specification at all, it may throw any exception.
</p>
<p>
Example:
</p>
<pre class="example">
void foo() throw(); // guaranteed not to throw an exception

void bar();         // may throw any exception
</pre>
<p>

However, it makes the most sense to assume that if you are calling a
function with no exception specification, it won't throw anything. It
also makes sense to assume that the function you are in may
throw anything, if it doesn't list an exception specification.
</p>
<p>
These assumptions are configurable in BEAM. See the parameter
<a href="parms.html#beam::no_throw_list">beam::no_throw_list</a>
for details.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR31"> -->
<a name="ERROR31"></a><h1>ERROR31: Re-throwing with no exception handler will terminate the
             application</h1>


It is valid to call <span class="function">throw()</span> with no throw expression
while within an exception handler. This will re-throw the
exception that is currently being handled by the exception handler.
However, calling <span class="function">throw()</span> outside of any exception
handler will immediately call the special function
<span class="function">terminate()</span>, which will terminate the application.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR32"> -->
<a name="ERROR32"></a><h1>ERROR32: Initialization of type may throw an
exception during exception handling</h1>


<h1>ERROR32: Destructor for variable may throw an exception
during exception handling</h1>

When an exception is thrown, some things happen behind the
scenes. This includes initializing the exception object that was
thrown, unwinding the stack to the correct exception handler, and
initializing the exception handler's parameter.
</p>
<p>
If a second exception is raised during these tasks, before the
exception handler for the original exception is entered, then the
special function <span class="function">terminate()</span> is called, which will
terminate the application.
</p>
<p>
It is dangerous to use classes as exception objects if their copy
constructors may throw an exception, because the copy constructors may
be invoked to initialize the thrown object or the parameter to
the exception handler.
</p>
<p>
It is also dangerous to declare an object on the stack if its
destructor may throw an exception, and if it is along a path
that will be unwound when a later exception is thrown.
</p>
<p>
Here are examples of both:
</p>
<pre class="example">
class A
{
public:
  A();
  A(const A &amp;) throw(int);
  ~A() throw(double);
};

void foo(A obj)
{
  ...
  throw(obj); // copy constructor may throw 'int' during initialization
  ...
}

void bar()
{
  A obj; // destructor may throw 'double' during stack unwind
  ...
  throw(...);
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR33"> -->
<a name="ERROR33"></a><h1>ERROR33: Shift amount is outside of the allowed range</h1>


</p>
<p>
Example:
</p>
<pre class="example">
int i = x;
i &lt;&lt;= 32;
</pre>
<p>

The C and C++ standards define the result of a shift operation only for 
positive shift amounts that are smaller than the width of the left operand.
For all other shift amounts the behavior is undefined which means that
the result is unpredictable and different compilers may produce different
results. For instance, the value of <span class="var">i</span> in above example can
be anything (assuming that <span class="code">sizeof(int) &lt;= 32</span>). 
Certain versions of xlc will produce a result of 0, whereas certain versions
of GCC will leave the value of <span class="var">i</span> unchanged.
</p>
<p>
If you are relying on one of these behaviors then you need to ensure
it by other means, perhaps a special shift function or macro.
</p>
<p>
The Java standard specifies that the shift amount is subject to a mod 
operation, which guarantees that the shift amount is in the valid range.
If, notwithstanding, you do turn ERROR33 on for a Java program,
we will assume that you do not mean to rely on that mod operation,
and this error will be issued whenever the right operand of a shift operation
is not in legal range.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR34"> -->
<a name="ERROR34"></a><h1>ERROR34: Failing assertion</h1>


</p>
<p>
Example1:
</p>
<pre class="example">
if (x &lt; 0)  x = -x;
assert(x &gt; 0);
</pre>
<p>

The above assertion will fail for x == 0.
</p>
<p>
We do not recommend that ERROR34 be turned on because of inadequate
assert facilities in most languages.
Consider the following.
</p>
<p>
Example2:
</p>
<pre class="example">
file = fopen(&quot;xyz&quot;, &quot;r&quot;);
assert(file);
</pre>
<p>

Suppose that your coding guidelines require that nobody rely on <span class="function">fopen()</span>
succeeding, and you expressed it using the <span class="code">force_test</span>
<a href="attributes.html">function attribute</a>.
That attribute tells BEAM that <span class="function">fopen()</span> can return NULL.
As a result BEAM will issue ERROR34 because the above assertion could fail.
</p>
<p>
The issue is that the above assert will fail if a file is missing,
which is not an error in your code.
You would like BEAM to issue complaints regarding asserts about your code only,
but there is no facility to distinguish them.
More generally, an asserts claims that an expression will be true for all
values of inputs, without specifying which inputs.
Ideally we would like to distinguish among asserts on inputs into a function,
inputs into a larger module, inputs into the whole program, etc.
Until there is such a distinction, it is not useful to check assertions statically.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR35"> -->
<a name="ERROR35"></a><h1>ERROR35: The expression expr1 modifies the same location assigned by the expression expr2</h1>


<h1>ERROR35: The expression expr1 modifies the same location used by the expression expr2</h1>

</p>
<p>
Example1:
</p>
<pre class="example">
i = 5;
a[i++] = i;
</pre>
<p>

The C and C++ language standard gives compilers considerable leeway 
in reordering expressions for evaluation.
In the above example a compile is free to first increment <span class="var">i</span>
in the array index and only then fetch the contents
of <span class="var">i</span> on the right hand side of the assignment. Or, the compiler 
is free to delay storing the new value of i until the end of the 
evaluation of the entire expression. Because of this, the effect of the 
example above is undefined, and no logical result can be assumed.
</p>
<p>
For this reason the language standard disallows certain expressions such as 
the array assignment in Example1.
The rules disallow even certain expressions where the final outcome would
happen to be the same no matter what the order of evaluation, as in 
</p>
<p>
Example2:
</p>
<pre class="example">
i++   +  i++; 
i = i = 5;
</pre>
<p>

Since the standard declares that the above expressions are undefined,
a compiler is free to, for example, set <span class="var">i</span> to 42, 
or do nothing with it. Therefore BEAM flags expressions like Example2 as 
well.
</p>
<p>
The exact rules of undefined expressions are rather involved 
and are not reproduced here.
But you are encouraged to look them up in your language document, usually
under "sequence points".
If you find the rules too complicated, a simple and safe rule of thumb is to
avoid sub-expressions with side-effects.
</p>
<p>
BEAM does not guarantee to find all violations, as illustrated in the 
following example.
</p>
<p>
Example3:
</p>
<pre class="example">
a[i] = a[j]++;
</pre>
<p>

Example3 is illegal if <span class="code">i=j</span>, but BEAM will flag it only 
if it can determine that <span class="code">i=j</span> from local context.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR36"> -->
<a name="ERROR36"></a><h1>ERROR36: NULL function pointer</h1>


This complaint is followed by a path though the program.
This paths ends in function call, e.g. <span class="code">foo(123)</span>, where
<span class="var">foo</span> is a function pointer whose value is NULL.
Such a call would cause a crash due to invalid instruction.
</p>
<p>
This usually happen inside a function <span class="function">bar</span> whose parameter 
is a function pointer <span class="var">foo</span>.
If the caller of <span class="function">bar</span> could pass NULL as value of <span class="var">foo</span>,
then <span class="var">foo</span> needs to be checked for NULL before used in a call.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR37"> -->
<a name="ERROR37"></a><h1>ERROR37: variadic function given wrong number of arguments</h1>


Some variadic function determine expected number of arguments from
data passed in.
That information is provided to BEAM using the function attribute 
<a href="attributes.html"><span class="code">vararg</span></a>.
ERROR37 is then issued for calls where the function is given
different number of arguments than what it expects.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR38"> -->
<a name="ERROR38"></a><h1>ERROR38(resource): Exceeding limit on resource</h1>


Some environments have a limit on the maximal amount of resources.
For example, embedded software may have a limit on stack size.
Also many operating systems have a limit on the number of files that can be 
open at any one time.
</p>
<p>
ERROR38 lets you specify such limits for various resources.
You can have a version for any resource, e.g.,
<span class="val">ERROR38(stack_memory), ERROR38(file), ERROR38(my_special_resource),</span>
where <span class="code">my_special_resource</span> might be a user defined resource.
<!-- </snippet> -->
</p>
<p>
The parameter <span class="var">limit</span> is a bound on the amount of the resource
that can be allocated at any one time.
If the resource name contains the string "memory" then the limit is number 
of bytes.
Otherwise the limit is the number of instances of the resource.
For example, <span class="code">beam::ERROR38(stack_memory)::limit</span> is the stack 
size in bytes,
while <span class="code">beam::ERROR38(file)::limit</span> limits the number of open files.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::ERROR38::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::ERROR38::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
 <td><span class="var">beam::ERROR38::limit</span>
 <td><span class="val">non-negative integer</span>
 <td>Complaint will be issued if the amount of allocated resource exceeds
the limit. 
The amount is measured in bytes for resources with "memory" in its name,
and is measured in allocated instances otherwise.
</tr>
</table>
</p>
<p>
Here is a general comment about resources.
Resources are allocated by functions with an allocator attribute,
see <a href="attributes.html">attribute</a>.
Part of the allocator attribute is a resource name;
for example, look at the definition of "fopen_like".
It is that resource name that is a parameter to ERROR38.
There is one exception -- stack_memory is a built-in resource
that gets allocated by calls to functions like alloca(), but also
by variable declarations.
For any of your own resource, you do need to define the resource as well as all
its allocators and deallocators.
</p>
<p>
At the present time the effectiveness of ERROR38 is limited to single functions.
We do not yet propagate resource information inter-procedurally.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR39"> -->
<a name="ERROR39"></a><h1>ERROR39: Undefined right shift of a negative number</h1>


The C and C++ standards declare as undefined the result of a right shift
applied to a negative number.
That means that
the outcome is unpredictable and different compilers may produce different
results.
What is worse, the standard actually allows a compiler to, for example,
generate the number 42 for any right shift of a negative number.
But BEAM is not that mean -- in the undefined case it follows 
the behavior of the host machine it is running on.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR41"> -->
<a name="ERROR41"></a><h1>ERROR41: Overwriting literal string</h1>


</p>
<p>
Example:
</p>
<pre class="example">
char *s = &quot;xyz&quot;;
s[1] = 'a';
</pre>
<p>

Modifying a string literal can cause the program to abort, if the compiler
chose to place them in read-only memory. If your compiler does this, BEAM
will complain. It recognizes command line flags that advise the compiler
to place string literals in memory that can be modified. It will not issue
the complaint in that case.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR43"> -->
<a name="ERROR43"></a><h1>ERROR43: Loop condition unchanged by loop body</h1>


<br>
Example:
</p>
<pre class="example">
while (p) {
  p-&gt;a = 42;
}
</pre>
<p>
The programmer probably forgot to advance the pointer <span class="var">p</span>.
The result is either an infinite loop or a noop, depending on whether
the initial value of <span class="var">p</span> is the NULL pointer or not.
</p>
<p>
Other common causes are misspelling of a variable name, or 
forgetting to declare a variable <span class="code">volatile</span>.
</p>
<p>
No ERROR43 will be issued for either of the two following loops,
which are common examples of intended infinite loops. 
</p>
<pre class="example">
while (1) {
  ...
}

for (;;) {
  ...
}
</pre>
<p>
If you do want BEAM to flag that <span class="code">while (1)</span>, or any other loop
with a constant condition then turn on MISTAKE5.
(ERROR43 is different from MISTAKE5, which reports conditions with identical
value for all program inputs; ERROR43 reports conditions that may have 
different value for different program inputs, but that value is not changed
by the loop.)
</p>
<p>
There is one situation where a programmer might intentionally
have a loop condition unchanged by loop body.
</p>
<pre class="example">
while (p) {
  if (foo()) return;
}
</pre>
<p>
That might be a somewhat obscure way of expressing
</p>
<pre class="example">
if (p) {
  while (1) {
    if (foo()) return;
  }
}
</pre>
<p>

If this is your coding style then
</p>
<pre class="example">
set beam::ERROR43::enabling_policy &quot;without_exit&quot;
</pre>
<p>

That setting will enable ERROR43 only for loops without any kind of
exit in the form of <span class="code">break</span>, <span class="code">goto</span>, <span class="code">return</span>, 
throwing an exception, or terminating the thread.
</p>
<p>
<!-- </snippet> -->
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR43::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any loop whose condition remains unchanged by the loop.
</tr>
<tr>
 <td><span class="var">beam::ERROR43::enabling_policy</span>
 <td><span class="val">&quot;without_exit&quot;</span>
 <td>The complaint is restricted to loops without any kind of exit.
</tr>
<tr>
 <td><span class="var">beam::ERROR43::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "ERROR44"> -->
<a name="ERROR44"></a><h1>ERROR44(Resource): Missing deallocation</h1>


The function fails to deallocate an instance of <span class="val">Resource</span>.
It does not actually leak the Resource, because it may be available
to the calling environment upon the function's return.
But it is likely that deallocation was intended.
<!-- </snippet> -->
</p>
<pre class="example">
Resource *global_variable;

void motivating_example()
{
  global_variable = new Resource;
  /* ... some code ... */
  if (something_unusual) return;
  /* ... some code ... */
  delete global_variable;
  global_variable = NULL;
}
  
void demotivating_example1()
{
  global_variable = new Resource;
  /* ... some code ... */
  if (something_unusual) {
    delete global_variable;
    global_variable = NULL;
    return;
  }
  /* ... some code not deleting the global_variable ... */
  return;
}
  
Resource *demotivating_example2()
{
  Resource *local_variable = new Resource;
  /* ... some code ... */
  if (something_condition) {
    delete local_variable;
    return NULL;
  }
  /* ... some code ... */
  return local_variable;
}
</pre>
<p>

In the <span class="function">modivating_example</span> the Resource is deallocated 
in the usual case, but not in the unusual.
This is a common ommission, which ERROR44 is to report.
Note that there is no resource leak; the Resource can be still deallocated
after the unusual return from <span class="function">motivating_example</span>.
</p>
<p>
The other two example show that deallocation along one path 
does not always imply the intention of always deallocating.
The <span class="function">demotivating_example1</span> demostrates the problem
of not knowing which execution paths are usual and which
are unusual.
In the case of <span class="function">demotivating_example2</span> any person looking at 
the code would understand
that the Resource is not meant to be deallocated along the path returning it.
</p>
<p>
BEAM uses several heuristics to identify paths that are likely to be
exceptional versus main line.
Depending on parameter settings (described below) deallocation
along main line will trigger ERROR44 for missing deallocations
on other paths.
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::ERROR44(Resource)::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued if the <span class="var">Resource</span> 
 is allocated and not deallocated within the same function.
</tr>
<tr>
 <td><span class="var">beam::ERROR44(Resource)::enabling_policy</span>
 <td><span class="val">&quot;sometimes&quot;</span>
 <td>Complaint will be issued if the <span class="var">Resource</span> 
 is allocated, then deallocated along a "usual" path, but
 not deallocated along another path.
 (What paths are "usual" is determined heuristically.)
</tr>
<tr>
 <td><span class="var">beam::ERROR44(Resource)::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
<tr>
 <td><span class="var">beam::ERROR44(Resource)::unknown_functions_effect</span>
 <td>pattern
 <td>If <span class="val">saves_parameter</span> matches the pattern then 
 this complaint will be suppressed along any path containing
 an unknown function being passed the resource.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE1"> -->
<a name="MISTAKE1"></a><h1>MISTAKE1: Statement has no effect</h1>


<h1>MISTAKE1: Expression has no effect</h1>

<h1>MISTAKE1: The value computed by an operation is not used</h1>

</p>
<p>
Example 1: (Probably missing '=')
</p>
<pre class="example">
x + 2;   /* Statement has no effect */
</pre>
<p>

Example 2: (Probably missing '=')
</p>
<pre class="example">
x &lt;&lt; 1;  /* Statement has no effect */
</pre>
<p>

Example 3:  (The address of a variable is never 0)
</p>
<pre class="example">
char x[100];
assert(x);  /* Statement has no effect */
</pre>
<p>

Example 4:  (Using comma instead of '=')
</p>
<pre class="example">
x, y = 0;  /* Expression `x' has no effect */
</pre>
<p>

Example 5:  (Using comma instead of '&&')
</p>
<pre class="example">
for (I = 0, J = 0;     I &lt; N, J &lt; M;      I++, J++) /* Expression `I &lt; N' has no effect */
</pre>
<p>

Example 6:  (Precedence error: *a++ instead of *(a++))
</p>
<pre class="example">
*a++;   /* The value computed by `*(a++)' is not used */
</pre>
<p>

Example 7:  (Whole statement has an effect, but last operation `+' does not)
</p>
<pre class="example">
x + foo();  /* The value computed by `x + foo()' is not used */
</pre>
<p>

In all of these cases, valid code results in something being
lost. Either the only effect of the expression is being ignored,
or there are effects of the expression that are being discarded
unintentionally, or the expression is unnecessary all together.
</p>
<p>
Look at the expression in question and see if it comes close to
any of these examples. Also look to see if the expression is
really doing what it was meant to do, and that the result of
the expression is really being used.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE2"> -->
<a name="MISTAKE2"></a><h1>MISTAKE2: Statement is unreachable</h1>


This complaint is issued because normally programmers do not intend to 
write unreachable statements.
Unreachable statements are the result of a label that is:
</p>
<p>
<ol>
  <li>not the target of any goto, or
  <li>testing an expression that is always true or always false, or 
  <li>an impossible case in a switch statement, or
  <li>preceding unconditional branch
</ol>
</p>
<p>
Example: (The label L is unreachable)
</p>
<pre class="example">
if (0 == 1) goto L;
return 0;
L: return 1;
</pre>
<p>

Another example of an unreachable statement is here
</p>
<pre class="example">
typedef enum {red, green} color;

int f(color c)
{
   switch(c)
     {
     case red:   return 0;
     case green: return 1;
     default:    return 2;
     }
}
</pre>
<p>

The default case will be flagged as unreachable, provided
the type <span class="var">color</span> is "clean"
(see <a href="parms.html#beam::clean_enum">beam::clean_enum</a>).
That means the variable <span class="var">c</span> cannot have a value other than
one listed by the enumerators of the type <span class="var">color</span>.
</p>
<p>
Look at the unreachable statements, and decide under which
circumstances they really should be reachable. If they should
never be reachable, think about removing them all together.
</p>
<p>
Note, that this complaint is not issued for statements that have no
effect. The rationale is that such statements can be removed anyway
without changing the program behavior and therefore that fact that they
cannot be reached is not interesting.
</p>
<p>
A handler of exceptions may appear unreachable just because functions are not
required to specify all the exceptions they can throw.
Consider this example.
</p>
<pre class="example">
try {
  foo1();
  foo2();
  cleanup();
} catch (...) {
  return;
}
</pre>
<p>

Consider the common case that none of the functions in the example 
specifies that it could throw an exception, and that according to the parameter
<a href="parms.html#beam::no_throw_list">beam::no_throw_list</a>
we should ignore the possibility that they might throw an exception.
Then the handler of the catch clause appears unreachable, and will be reported as
such. That can be suppressed by the extra parameter <span class="var">beam::MISTAKE2::enabled_for_handler</span>.
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE2::enabled_for_handler</span>
 <td><span class="val">&quot;yes&quot;</span>
 <td>Complaint will be issued for unreachable exception handlers.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE2::enabled_for_handler</span>
 <td><span class="val">&quot;no&quot;</span>
 <td>Complaint will not be issued for exception handlers.
</tr>
</table>
</p>
<p>
MISTAKE2 is usually accompanied by MISTAKE5 (an impossible test branch) or
WARNING8 (label is not the target of any goto).
If you decide to turn on MISTAKE2, it is a good idea to also turn on 
the other two as they may provide an explanation of the cause.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE3"> -->
<a name="MISTAKE3"></a><h1>MISTAKE3: Beware, relation == binds more tightly than &</h1>


Operator precedence defined by the programming language is not always 
expected by programmers. In this case, what was written is probably
not what was meant, and should be inspected for correctness.
</p>
<p>
Common causes include assuming the wrong precedence, using the wrong
operator, or forgetting parenthesis around part of the expression.
</p>
<p>
Example:
</p>
<pre class="example">
if (A&amp;B == 0)
</pre>
<p>

should probably be
</p>
<pre class="example">
if ((A&amp;B) == 0)
</pre>
<p>

In the above example the programmer probably expected '&' to bind more tightly
than '==', which is the opposite of the C language definition.
</p>
<p>
Examine the expression and decide which precedence was intended. When
in doubt as to what the language defines the precedence to be, use
extra parenthesis.
<!-- </snippet> -->
</p>
<p>
The parameter <span class="var">unexpectedly_tighter</span> allows user to specify where his expectations 
are different from the language definition.
For example,
</p>
<pre class="example">
lappend beam::MISTAKE3::unexpectedly_tighter(&amp;)    &quot;==&quot; &quot;!=&quot;
</pre>
<p>

will cause complaints for these two types of expressions:
</p>
<pre class="example">
if (A&amp;B == 0) 
if (A&amp;B != 0)
</pre>
<p>

<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE3::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any expression of the
     form "a op1 b op2 c" (or "a op2 b op1 c"), where 
     op2 binds more tightly than op1 and op2 is on the 
     list "unexpectedly_tighter(op1)".
</tr>
<tr>
 <td><span class="var">beam::MISTAKE3::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued
</tr>
<tr>
 <td><span class="var">beam::MISTAKE3::unexpectedly_tighter(<span class="val">operator</span>)</span>
 <td>list of operators
 <td>see above
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE4"> -->
<a name="MISTAKE4"></a><h1>MISTAKE4: A break might be missing</h1>


When executing a <span class="code">case</span> statement, the execution path
will continue through all <span class="code">case</span> statements until a
<span class="code">break</span> is encountered. This means that more than one
<span class="code">case</span> statement might be executed accidentally.
</p>
<p>
Example:
</p>
<pre class="example">
switch (A)
{
  case 0: B = 0;
  case 1: B = 1;
}
</pre>
<p>

Without a break statement, after assigning 0 to B, 1 will be assigned
to B.
</p>
<p>
Look at your case statements. If you intend to fall through from one
statement to the next, consider marking this error
innocent. Otherwise, insert the appropriate <span class="code">break</span>
statements so that the execution path is correct.
</p>
<p>
Sometimes it is intended to fall from one case to the next.
The most common example is 
</p>
<pre class="example">
switch (A)
{
  case 0: 
  case 1: B = 1;
}
</pre>
<p>

This is so common that BEAM will not issue any complaint regarding cases with no statements,
such as case 0.
<!-- </snippet> -->
</p>
<p>
The value of enabling_policy is a  <a href="parms.html#patterns">pattern</a>
with the following meaning.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever applicable.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::enabling_policy</span>
 <td><span class="val">&quot;any_jump&quot;</span>
 <td>Complaint will be issued only if there is any jump out of the case
(goto, break, continue, return).
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will be never issued.
</tr>
</table>
</p>
<p>
The option "any_jump" was requested by a user so that he can
</p>
<pre class="example">
set beam::MISTAKE4::enabling_policy  &quot;always - any_jump&quot;
</pre>
<p>

This setting will suppress MISTAKE4 if there is any conditional
jump out of a case.
We do not recommend this setting because it would fail to report 
a common situation where a break is only conditional and the programmer 
intends it to be unconditional.
</p>
<p>
In case of an intentional fall-through, many programmers include a disabling_comment
to inform others.
There is a question of where the comment should be.
Consider the following example.
</p>
<pre class="example">
switch (A)
{
  case L0: a = 0;
           b = 0;
  case L1: a = 1; /* FALLTHROUGH */
           b = 1;
  case L2: a = 2;
           b = 2;
}
</pre>
<p>

Is the comment referring to the fall-through from L0 to L1, or from L1 to L2?
The user can inform BEAM how to interpret the comment using the Tcl variable 
<span class="var">beam::MISTAKE4::disabling_comment_policy</span>.
Every check has this variable 
<a href="parms.html#beam::check::disabling_comment_policy">
beam::<span class="val">check</span>::disabling_comment_policy</a>,
whose value is a string containing "L" meaning the line identified in the complaint.
But in case of MISTAKE4, the string can also contain "L1" or "L2"
referring to the label we are falling from and the
label we are falling into.
To understand its setting think where the comment could be when talking about the fall-through from L1 to L2.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE4::disabling_comment_policy</span>
 <td> "L1+1 to L2-1"
 <td>Comment can be between L1 and L2, not including either.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::disabling_comment_policy</span>
 <td>"L1+1 to L2"
 <td>Comment can be between L1 and L2, not including L1.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::disabling_comment_policy</span>
 <td>"L1 to L2-1"
 <td>Comment can be between L1 and L2, not including L2.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::disabling_comment_policy</span>
 <td>"L1 to L2"
 <td>Comment can be between L1 and L2, including both.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE4::disabling_comment_policy</span>
 <td>"L2-1"
 <td>Comment must be on the line just before L2.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE5"> -->
<a name="MISTAKE5"></a><h1>MISTAKE5:  The expression xyz always evaluates to ...</h1>


Normally people do not mean to test conditions that are always true or
always false.
</p>
<p>
Example 1:
</p>
<pre class="example">
if (strlen(S) &gt;= 0)  /* Condition is always true */
</pre>
<p>

Example 2:
</p>
<pre class="example">
typedef enum {A, B} AB;

void foo(AB ab)
{
  switch(ab)
    {
    case 0: break;    /* Case is possible */
    case 1: break;    /* Case is possible */
    case 2: break;    /* Case is not possible */
    default: break;   /* Default is not possible */
    }
}
</pre>
<p>

Common causes include testing the wrong conditional, using the wrong
operator (= instead of ==), using operators that evaluate in an
unexpected order, or testing a condition that has already been tested
for.
<!-- </snippet> -->
</p>
<p>
Following this complaint BEAM prints some possible causes.
For this purpose causes of MISTAKE5 are divided into the following categories,
which can be specified in <span class="var">enabling_policy</span>.
The table briefly lists the categories, which is followed by a more detailed explanation.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_local&quot;</span>
 <td>Cause is in the same conditional statement
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_non_local&quot;</span>
 <td>Caused by another conditional statement
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_declaration&quot;</span>
 <td>e.g. if(x <= MAX)
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_sizeof&quot;</span>
 <td>e.g. if(sizeof(int) == sizeof(long))
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_literal&quot;</span>
 <td>e.g. if(1)
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_operation_on_literals&quot;</span>
 <td>e.g. if(1 + 1 == 2)
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_right_of_assignment&quot;</span>
 <td>e.g. if(x = 1)
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_implied_from_call&quot;</span>
 <td>e.g. if(foo())
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;condition_inexplicable&quot;</span>
 <td>None of the above
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>All of the above
</tr>
<tr>
 <td><span class="var">beam::MISTAKE5::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will be never issued
</tr>
</table>
</p>
<p>
<UL>
<br><li><span class="strong">condition_implied_from_local</span><br><br>
Example:
</p>
<pre class="example">
if (x &gt;= MIN || x &lt;= MAX)
  ...
</pre>
<p>

This is an example of a common mistake when testing whether <span class="var">x</span> is
in the range between <span class="var">MIN</span> and <span class="var">MAX</span>.
(The mistake is in writing || instead of &&).
The symptom of the mistake is that the expression <span class="code">x &lt;= MAX</span>
is always true whenever evaluated; and it is evaluated only if 
<span class="code">x &gt;= MIN</span> is false.
</p>
<p>
Another example:
</p>
<pre class="example">
if (x &gt; A || x &lt;= A &amp;&amp; y &gt; B)
  ...
</pre>
<p>

This is a common coding practice where the unnecessary condition <span class="code">x &lt;= A</span>
is added for clarity.
If this is your coding style then you can disable this category of MISTAKE5
by removing <span class="strong">condition_implied_from_local</span> from <span class="var">enabling_policy</span>.
</p>
<p>
<br><li><span class="strong">condition_implied_from_non_local</span><br><br>
Example:
</p>
<pre class="example">
if (x &gt; 5)
{
   if (x &gt;= 5) ...
}
</pre>
<p>

The condition <span class="code">x &gt;= 5</span> is always true because it is executed only if 
<span class="code">x &gt; 5</span>, and BEAM will identify that reason.
A common cause is testing the wrong variable in one of the two conditions.
Sometimes unnecessary condition are tested just to make sure,
and if this is your coding style you need to disable this category.
</p>
<p>
<br><li><span class="strong">condition_implied_from_declaration</span><br><br>
Example:
</p>
<pre class="example">
char c;
for (c = 0; c &lt; 256; c++)
</pre>
<p>

This is a common mistake resulting in an infinite loop, whose symptom is that 
the condition <span class="code">c &lt; 256</span> is always true.
It is always true independently of any other conditions, and the 
reasons can be ascertained by looking at the variables involved and
their declarations.
</p>
<p>
<br><li><span class="strong">condition_implied_from_sizeof</span><br><br>
Example:
</p>
<pre class="example">
if (sizeof(int) == sizeof(long))
</pre>
<p>

On any particular machine this condition will be always true or always false.
We recognize this special category so that it can be removed from <span class="var">enabling_policy</span>.
</p>
<p>
<br><li><span class="strong">condition_implied_from_operation_on_literals</span><br><br>
Example:
</p>
<pre class="example">
if (1 + 1 == 2)
</pre>
<p>

This type of condition usually occurs as a result of macro expansion.
We recognize this special category so that it can be removed from <span class="var">enabling_policy</span>.
</p>
<p>
<br><li><span class="strong">condition_implied_from_literal</span><br><br>
Example:
</p>
<pre class="example">
if (1) ...
if (x == 0 || 1) ...
</pre>
<p>

The condition is an explicit literal constant.
The first example is common and usually intended.
The second example is also common and rarely intended.
</p>
<p>
You probably want to enable checking for the second one and disable the first one.
For that reason we distinguish between  <span class="val">whole_condition_implied_from_literal</span>
and  <span class="val">sub_condition_implied_from_literal</span> as explained below.
</p>
<p>
<br><li><span class="strong">condition_implied_from_right_of_assignment</span><br><br>
Example:
</p>
<pre class="example">
if (x = 1) ...
</pre>
<p>

Writing  <span class="code">=</span> instead of  <span class="code">==</span>
often results in a condition that is always true or always false.
The reason is that the value of the condition is the value of the right hand side 
of the assignment.
This category applies to all assignments independently of the causes why the
the right hand size is always true or always false.
</p>
<p>
<br><li><span class="strong">condition_implied_from_call</span><br><br>
Example:
</p>
<pre class="example">
if (foo()) ...
</pre>
<p>

If foo() can never return 0 then the condition is always true.
BEAM knows about the possible return values of <span class="function">foo()</span> 
either from a user declared <a href="attributes.html">attribute</a>
or from examining the body of <span class="function">foo()</span>.
</p>
<p>
<br><li><span class="strong">condition_inexplicable</span><br><br>
None of the above categories applies.
</p>
<p>
Example:
</p>
<pre class="example">
if ((x || y) &amp;&amp; (!x || y) &amp;&amp; (x || !y) &amp;&amp; (!x || !y))
</pre>
<p>

In every particular case you might see the reason and wonder why BEAM 
could not print the reason.
We are trying to improve our diagnostic abilities,
but we will never be able to do a good job in all cases.
You may find this example particularly surprising:
</p>
<pre class="example">
x = 0;
if (x == 0) ..
</pre>
<p>

For reasons too difficult to explain
BEAM is unable to pinpoint the assignment as the cause why 
<span class="code">x == 0</span> is always true.
</UL>
</p>
<p>
Which of the categories are desired can be expressed by including them in 
<span class="var">enabling_policy</span>.
For example,
</p>
<pre class="example">
set beam::MISTAKE5::enabling_policy &quot;condition_implied_from_literal condition_inexplicable&quot;
set beam::MISTAKE5::enabling_policy {condition_implied_from_literal 
                                     condition_inexplicable
                                     }
</pre>
<p>

Those two settings are equivalent and enable the two listed categories.
(Using the <span class="code">{...}</span> syntax instead of <span class="code">&quot; ...&quot;</span>
is sometimes more convenient for long strings.)
</p>
<p>
As usual, the term <span class="term">always</span> means that all categories are enabled.
The value of <span class="var">enabling_policy</span> is a <a href="parms.html#patterns">pattern</a>,
whose terms are the categories listed above; for example
</p>
<pre class="example">
set beam::MISTAKE5::enabling_policy &quot;always - condition_inexplicable&quot;
</pre>
<p>

This setting will cause MISTAKE5 to be printed in all cases except when
<span class="val">condition_inexplicable</span>.
</p>
<p>
As mentioned above each of the categories, instead of  <span class="val">condition</span>
can refer to  
</p>
<p>
<table>
<tr><td><span class="val">whole_condition</span> <td>e.g. <span class="code"> if (Cond)</span> 
<tr><td><span class="val">sub_condition</span>   <td>e.g. <span class="code"> if (x == 0 || Cond) or if (x == 0 &amp;&amp; Cond)</span>
<tr><td><span class="val">case_condition</span>  <td>e.g. <span class="code"> case Cond: </span> 
<tr><td><span class="val">default_condition</span><td> e.g. <span class="code"> default: </span>
</table>
</p>
<p>
For example,
</p>
<pre class="example">
if (1) ...
if (x == 0 || 1) ...
case 1:
</pre>
<p>

The condition <span class="code">1</span> appears as whole_condition in the 
first if statement, as sub_condition in the second, and
as case_condition in the third.
</p>
<pre class="example">
set beam::MISTAKE5::enabling_policy                &quot;condition_implied_from_literal&quot;
set beam::MISTAKE5::enabling_policy            &quot;sub_condition_implied_from_literal&quot;
set beam::MISTAKE5::enabling_policy &quot;always - whole_condition_implied_from_literal&quot;
set beam::MISTAKE5::enabling_policy           &quot;case_condition_*&quot;
</pre>
<p>

The first setting would result in a complaint for both of the if-statements,
while the second and third settings would result in a complaint for the second if-statements only.
The fourth setting would cause a complaint for the case statement, provided
the expression in the switch statement cannot be <span class="code">1</span> for any reason.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE6"> -->
<a name="MISTAKE6"></a><h1>MISTAKE6: The third argument of strncmp should probably be ...</h1>


When using <span class="function">strncmp</span>, the <span class="var">length</span> argument
is usually meant to be the length of the smaller of the two strings.
</p>
<p>
Example:
</p>
<pre class="example">
if (!strncmp(S, &quot;abcd&quot;, 3))
</pre>
<p>

Here the third argument should probably be 4.
Otherwise <span class="var">S</span> is being compared against "abc" only.
<!-- </snippet> -->
</p>
<p>
The value of <span class="var">enabling_policy</span> is a <a href="parms.html#patterns">pattern</a>,
whose terms are of the form "strlen+k" and "strlen-k" for some number k.
The complaint is issued if the <span class="var">length</span> argument exceeds 
the string length of a given string by the amount k.
In the the above example the complaint would be issued for any of these settings
</p>
<pre class="example">
set beam::MISTAKE6::enabling_policy &quot;strlen-1&quot;; # complain if length == 3
set beam::MISTAKE6::enabling_policy &quot;strlen-*&quot;; # complain if length &lt;  4
set beam::MISTAKE6::enabling_policy &quot;always&quot;;   # complain if length != 4
</pre>
<p>

The default setting is 
</p>
<pre class="example">
set beam::MISTAKE6::enabling_policy &quot;always - strlen+1&quot;; # complain if length != 4 and != 5
</pre>
<p>

Thus, by default the complaint will be suppressed for
</p>
<pre class="example">
if (!strncmp(S, &quot;abcd&quot;, 5))
</pre>
<p>

which is is equivalent to 
</p>
<pre class="example">
if (!strcmp(S, &quot;abcd&quot;))
</pre>
<p>

The reason for this default setting is that there is a common belief that the function 
<span class="function">strcmp</span> is not secure and <span class="function">strncmp</span>
should be used instead.
That is not true -- <span class="function">strcmp</span> is just as secure as <span class="function">strncmp</span>;
this belief probably originated from the fact that 
<span class="function">strcpy</span> is not as secure as <span class="function">strncpy</span>.
Nevertheless, to avoid complaining about the misguided use of <span class="function">strncmp</span>
we suppress that special case.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE7"> -->
<a name="MISTAKE7"></a><h1>MISTAKE7: The variable xyz already controls the loop on line ...</h1>


Using the same variable to control nested loops can cause unwanted
side effects on the loop conditional tests, which is rarely intended.
</p>
<p>
Example 1:
</p>
<pre class="example">
for (I = 0; I &lt; N; I++)
  for (I = 0; I &lt; M; I++)
</pre>
<p>

will cause the complaint
</p>
<pre class="example">
&quot;f.C&quot;, line 123: The variable 'I' already controls the loop on line 122
</pre>
<p>

Example 2:
</p>
<pre class="example">
while (I &lt; N)
  for (I = 0; I &lt; M; I++)
</pre>
<p>

Again the inner loop has a side-effect on the test of the outer while loop.
However, this situation is more often intended than the situation in 
Example 1. Therefore there a setting of <span class="var">beam::enabling_policy</span> that allows generation
of complaints for Example 1, while disabling complaints for Example 2.
</p>
<p>
No complaint will be issued if the inner for-loop contains no initializer, as in this example.
</p>
<pre class="example">
while (I &lt; N)
  for (; I &lt; M; I++)
</pre>
<p>

The lack of initializer in a for-loop is an indication that the programmer does intend the side-effect.
</p>
<p>
Check the variables that are controlling the nested loops, and be sure
that they should be the same variable. If not, change them so that the
loops have separate controlling variables.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE7::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for a for-loop nested in another loop,
     where the increment of the inner for-loop effects the test of the 
     outer loop.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE7::enabling_policy</span>
 <td><span class="val">&quot;only_for_loops&quot;</span>
 <td>Complaint will be issued only if the outer loop is also a for-loop.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE7::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE8"> -->
<a name="MISTAKE8"></a><h1>MISTAKE8: The size argument of malloc should probably 
involve sizeof(type)</h1>


This check complains if the size of allocated memory looks somehow
suspicious. For instance:
</p>
<pre class="example">
long *Array = malloc(11 * sizeof(long *));
</pre>
<p>

should probably be 
</p>
<pre class="example">
long *Array = malloc(11 * sizeof(long));
</pre>
<p>

Likewise:
</p>
<pre class="example">
long *Array = realloc(Array, 64);
</pre>
<p>

should probably be 
</p>
<pre class="example">
long *Array = realloc(Array, 64 * sizeof(long));
</pre>
<p>

By default BEAM considers a size suspicious if it is not a multiple 
of the size of the element-type of the array that is being allocated.
In this mode, there would be a complaint about the first example but
not about the second, because 64 by itself already is a multiple of 
<span class="code">long</span>. 
To catch the latter the enabling_policy must be set to "strict". In that
case a the presence of a <span class="code">sizeof</span> expression is required.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE8::enabling_policy</span>
 <td><span class="val">&quot;multiple&quot;</span>
 <td>Complaint will be issued if allocated size is not a multiple of the
     size of the element type of the allocated array.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE8::enabling_policy</span>
 <td><span class="val">&quot;strict&quot;</span>
 <td>Complaint will be issued if the size expression does not contain a
     <span class="code">sizeof</span> expression and its value is not a multiple of the
     size of the element type of the allocated array.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE8::enabling_policy</span>
 <td><span class="val">&quot;multiple_or_sizeof&quot;</span>
 <td>Complaint will be issued if the size expression does not contain a
     <span class="code">sizeof</span> expression or its value is not a multiple of the
     size of the element type of the allocated array.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE8::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Same as "multiple". This is provided for backward compatibility with
     earlier versions of BEAM.
</tr>
</table>
</p>
<p>
The "multiple_or_sizeof" policy is useful when you allocate structures
with an extensible array at the end. Like so:
</p>
<pre class="example">
struct foo {
   int n;
   int array[1];
} *var;

var = malloc(sizeof(struct foo) + 7 * sizeof(int));
</pre>
<p>

Assuming 4-byte integers the allocated size is 36 bytes and therefore not
a multiple of <span class="code">struct foo</span> which consumes 8 bytes. With default
settings BEAM will produce a complaint which is not what is desired here.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE10"> -->
<a name="MISTAKE10"></a><h1>MISTAKE10: Trying to allocate invalid amount of memory</h1>


Passing an invalid value to an allocator can result in anything from
failing to get the intended memory to crashing the application.
Some functions allocating memory are unable to satisfy a request for 0 bytes
or for a negative amount of bytes. If this happens MISTAKE10 is issued.
</p>
<p>
Common causes include not checking the size being passed to an
allocator, or allocating a negative amount of memory by mistake.
</p>
<p>
Things to look for include where the size being allocated is
calculated, and why it is invalid. Ensure that the request contains a
valid size, so that memory can be returned successfully.
</p>
<p>
BEAM recognizes a function as allocating memory when it is given such an
<a href="attributes.html">attribute</a>.
Part of the attribute specifies what the function will do what asked
for 0 bytes or for a negative number of bytes.
For an example, see the usage of  <span class="var">malloc_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE11"> -->
<a name="MISTAKE11"></a><h1>MISTAKE11: The function will be invoked more than once with identical arguments</h1>


This is usually a symptom of unintentionally invoking a function more
than once with the same arguments. Invoking a function in such a
manner (if it was unintended) is inefficient, and may be incorrect if
the function has any side-effects.
BEAM will issue the complaint iff the function invocations stem from a
macro expansion.
</p>
<p>
Example:
</p>
<pre class="example">
#define MIN(a,b) a &lt; b ? a : b
...
MIN(foo(), 5)
</pre>
<p>

The macro MIN may invoke the function <span class="function">foo</span> twice.
It is better to code it like this:
</p>
<pre class="example">
t = foo();
MIN(t, 5)
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE11::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::MISTAKE11::enabling_policy</span>
 <td><span class="val">&quot;no_side_effect&quot;</span>
 <td>Complaint will be issued if the function is known to BEAM to have no 
     side-effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE11::enabling_policy</span>
 <td><span class="val">&quot;some_side_effect&quot;</span>
 <td>Complaint will be issued if the function is known to BEAM to have a 
     side-effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE11::enabling_policy</span>
 <td><span class="val">&quot;unknown_side_effect&quot;</span>
 <td>Complaint will be issued if the function is unknown to BEAM
</tr>
<tr>
 <td><span class="var">beam::MISTAKE11::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
The value of <span class="var">enabling_policy</span> is a 
<a href="parms.html#patterns">pattern</a>, whose terms are "no_side_effect", 
"some_side_effect" and "unknown_side_effect".
A typical setting would be 
</p>
<pre class="example">
set beam::MISTAKE11::enabling_policy  &quot;always - no_side_effect&quot;
</pre>
<p>

This setting will cause a complaint for functions where BEAM knows they have 
a side-effect or is unsure.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE12"> -->
<a name="MISTAKE12"></a><h1>MISTAKE12: 1-st argument arg of abs will lose
precision. Consider using fabs instead</h1>


The function <span class="function">abs</span> converts its argument to an integer
before computing the absolute value. In the cases where the argument
is a float or double (or long), precision will be lost.
</p>
<p>
Example:
</p>
<pre class="example">
double d = 1.5;
double a = abs(d);
</pre>
<p>

This was probably meant to be <span class="function">fabs</span>, which handles floating 
point numbers.
</p>
<p>
In general, ensure that the type of the variable you are passing to
certain functions is compatible with the type of the argument that the
function expects.
<!-- </snippet> -->
</p>
<p>
The function <span class="function">abs</span> is only an example of functions that could cause
unexpected loss of precision.
The parameter <span class="var">instead_of</span> can be used to specify more such functions.
It takes two parameters. The first is the qualified name of the function
and the second is a qualified type name. The complaint is issued when
an argument of the specified type is passed to the specified function.
</p>
<p>
This is how the information for <span class="function">abs</span> is specified
</p>
<pre class="example">
set &quot;beam::MISTAKE12::instead_of(abs,float)&quot;  &quot;fabs&quot;
set &quot;beam::MISTAKE12::instead_of(abs,double)&quot; &quot;fabs&quot;
set &quot;beam::MISTAKE12::instead_of(abs,long)&quot;   &quot;labs&quot;
</pre>
<p>

<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE12::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for function calls.
     <span class="code">foo(..., x, ...)</span>, where <span class="var">x</span> is of type 
     <span class="var">t</span>, and the parameter <span class="var">instead_of(foo,t)</span> is set.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE12::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE13"> -->
<a name="MISTAKE13"></a><h1>MISTAKE13: In an enum two enumerators have the same value</h1>


Most of the time, enumerators are meant to contain distinct
values. This complaint is issued when an enumeration maps more than
one enumerator to the same value.
</p>
<p>
Example:
</p>
<pre class="example">
enum {
  A,
  B,
  C,
  D = 0x01,
  E
};
</pre>
<p>

BEAM will issue the following two complaints
</p>
<pre class="example">
The enumerator D has the same value 1 as B
The enumerator E has the same value 2 as C
</pre>
<p>

Common causes include assigning the wrong value to one of the
enumerators, or assigning values at all. If this was intended, it
should be marked innocent, or (if it happens commonly throughout this
code), the complaint should be disabled.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE14"> -->
<a name="MISTAKE14"></a><h1>MISTAKE14: Implicit declaration of function foo.</h1>


The C language does not require that functions be declared before use,
but it is generally recommended.
The C compiler will issue a warning for undeclared functions and
the linker will actually fail if an implementation of the function 
is not provided.
</p>
<p>
Therefore this complaint is not intended to catch programming errors,
but rather failures to provide some include files.
It is recommended that this complaint be turned on because otherwise 
BEAM may issue other complaints, which the user might find hard to 
understand. The real cause might be a missing include file or
incorrect defines given to BEAM.
</p>
<p>
Common causes include misspelled function or type names, or missing include
files. Determine if the correct function or type is being used, and if
so, include the appropriate header files that define that
function or type.
</p>
<p>
If many functions are intended to be undeclared, then this complaint
could result in too much noise. In that case it is recommended that
<span class="var">beam::enabling_policy</span> be set to "capitals". This will
cause the complaint to be issued only for functions whose name
is all in capitals, which was probably meant to be a macro, but
its definition was omitted. 
</p>
<p>
In any case this complaint is issued only once per source file and 
undeclared function.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE14::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for every call to an undeclared function.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE14::enabling_policy</span>
 <td><span class="val">&quot;capitals&quot;</span>
 <td>Complaint will be issued for every call to an undeclared function 
     whose name uses no small letters.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE14::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE15"> -->
<a name="MISTAKE15"></a><h1>MISTAKE15: Lack of parenthesization around macro definition 
foo could result in an incorrect evaluation when expanded</h1>


<h1>MISTAKE15: Lack of parenthesization around parameter parm of 
macro foo could result in an incorrect evaluation when expanded</h1>

</p>
<p>
This check is no longer available.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE16"> -->
<a name="MISTAKE16"></a><h1>MISTAKE16(while): The while-construct is followed by a semicolon, resulting in an empty body</h1>


<h1>MISTAKE16(for): The for-construct is followed by a semicolon, resulting in an empty body</h1>

<h1>MISTAKE16(switch): The switch-construct is followed by a semicolon, resulting in an empty body</h1>

<h1>MISTAKE16(if): The if-statement has an empty then-clause and no else-clause</h1>

</p>
<p>
Example1:
</p>
<pre class="example">
while (a &gt; b);
  foo();
</pre>
<p>

Example2:
</p>
<pre class="example">
for (p = str; *p != '?'; p++);
foo();
</pre>
<p>

Example3:
</p>
<pre class="example">
switch (x);
{
  case 0: ...
}
</pre>
<p>

</p>
<p>
Example4:
</p>
<pre class="example">
{
  if (a &gt; b);
}
</pre>
<p>

</p>
<p>
Example5:
</p>
<pre class="example">
{
  if (a &gt; b);
  else x++;
}
</pre>
<p>

There are several language constructs -- 
<span class="code">while</span>, <span class="code">for</span>, <span class="code">switch</span>, <span class="code">if</span> --
that apply  to the next single
statement or block of code.
A semi-colon denotes the end of a
single statement, and therefore a spurious semi-colon after one of 
these constructs will give those constructs an empty body.
</p>
<p>
A human eye is bad at noticing spurious semi-colons and sees
the next non-empty statement as the body of the construct.
At the same time it is possible that the semi-colon is actually an intentional
expression of an empty body.
In Example1 the call to <span class="code">foo()</span> is probably meant to be 
executed on every iteration of the while-loop,
but in Example2 the same call is probably meant to be executed only after 
the for-loop.
That intention is conveyed by indentation.
Similarly the semi-colon in Example3 is almost surely unintended,
judging from the following block of code.
(Please note that Example3 is syntactically correct in C/C++,
provided it is embedded in another switch statement.
Example3 is not syntactically correct in Java.)
</p>
<p>
An if-statement is somewhat different in that it applies to two 
statements -- then and else clauses.
While Example4 shows an if-statement with no effect,
the semi-colon in Example5 is quite surely intended because 
it would not be syntactically correct otherwise.
</p>
<p>
MISTAKE16 reports spurious semi-colons and its <span class="var">enabling_policy</span>
allows you to express when MISTAKE16 should be suppressed because
you actually do mean an empty body.
<!-- </snippet> -->
</p>
<p>
<span class="var">beam::ERROR1(construct)::enabling_policy</span> is a <a href="parms.html#patterns">pattern</a>,
whose terms are 
<span class="val">&quot;block_stmt&quot;</span>, <span class="val">&quot;indented_stmt&quot;</span>, <span class="val">&quot;unindented_stmt&quot;</span>, and
<span class="val">&quot;no_stmt&quot;</span>.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">enabling_policy</span>
 <td><span class="val">&quot;block_stmt&quot;</span>
 <td>Complaint will be issued provided the construct is
 followed by a block statement.
</tr>
<tr>
 <td><span class="var">enabling_policy</span>
 <td><span class="val">&quot;indented_stmt&quot;</span>
 <td>Complaint will be issued provided the construct is
 followed by a non-block statement that is indented with respect to
 the construct.
</tr>
<tr>
 <td><span class="var">enabling_policy</span>
 <td><span class="val">&quot;unindented_stmt&quot;</span>
 <td>Complaint will be issued provided the construct is
 followed by a non-block statement that is not indented with respect to
 the construct.
</tr>
<tr>
 <td><span class="var">enabling_policy</span>
 <td><span class="val">&quot;no_stmt&quot;</span>
 <td>Complaint will be issued provided the construct is
 followed by no statement at all, i.e. it is at the end of a block.
</tr>
</table>
</p>
<p>
Example1 will trigger the complaint, provided
<span class="var">beam::MISTAKE16(while)::enabling_policy</span> contains <span class="val">&quot;indented_stmt&quot;</span>.
</p>
<p>
Example2 will trigger the complaint, provided
<span class="var">beam::MISTAKE16(for)::enabling_policy</span> contains <span class="val">&quot;unindented_stmt&quot;</span>.
</p>
<p>
Example3 will trigger the complaint, provided
<span class="var">beam::MISTAKE16(switch)::enabling_policy</span> contains <span class="val">&quot;block_stmt&quot;</span>.
</p>
<p>
Example4 will trigger the complaint, provided
<span class="var">beam::MISTAKE16(if)::enabling_policy</span> contains <span class="val">&quot;no_stmt&quot;</span>.
</p>
<p>
Example5 will never trigger the complaint.
As usual all the examples 1,2,3,4 will trigger the complaint 
if the <span class="var">enabling_policy</span> is <span class="val">&quot;always&quot;</span>.
</p>
<p>
The notion of "indentation" may not be objective if some lines in your source code
contain tabs and others do not.
Then two programmers looking at the same piece of code with different
editor settings will disagree on what is and is not indented.
For the same reason BEAM may see indentation differently than you do.
This is another argument against inconsistent use of tabs.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE17"> -->
<a name="MISTAKE17"></a><h1>MISTAKE17: Loop will be executed at most once</h1>


If a loop is encountered that will never execute more than once,
then either the loop construct was not needed, or more likely, there
is an error in the logic that decides when to exit the loop.
</p>
<p>
Example:
</p>
<pre class="example">
for (i = 0; i &lt; n; i++)
{
  ... some statements not containing &quot;continue&quot; ...
  break;
}
</pre>
<p>

This loop will break on the very first iteration, therefore the loop
construct is not needed. This is sometimes an indication of an error
in the conditions for terminating the loop.
</p>
<p>
The exact cause for this error is tough to track down sometimes. Some
things to look for include any <span class="code">break</span> or
<span class="code">continue</span> statements in the loop, and under what
conditions they are encountered. Also look at the loop's conditional
statement, and ensure that it is correct and executes the loop as many
times as you expect it to. When all else fails, use a debugging
technique to watch the variables and the loop iterations to better
understand what is happening.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE18"> -->
<a name="MISTAKE18"></a><h1>MISTAKE18: Comparing pointers to strings, not the strings themselves.</h1>


<h1>MISTAKE18: Comparing pointers, not the objects themselves.</h1>

</p>
<p>
Example 1:
</p>
<pre class="example">
void foo(char *string1, char *string2)
{
  if (string1 == string2) ...
}
</pre>
<p>

This will compare whether string1 and string2 are identical pointers
and will evaluate to false whenever the pointers are different,
even if their two character strings are the same.
If you meant to check whether the strings were the same, you want to write it as
</p>
<pre class="example">
void foo(char *string1, char *string2)
{
  if (strcmp(string1, string2) == 0) ...
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE18::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for expressions 
     <span class="code">x==y</span> or <span class="code">x!=y</span>
     provided the type of <span class="var">x</span> and  <span class="var">y</span>
     is specified in the parameter compare_function.
     In any case no complaint will be issued if x or y is 0.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE18::enabling_policy</span>
 <td><span class="val">&quot;no_overlap&quot;</span>
 <td>Complaint will suppressed if comparing two pointers that could point 
     into the same memory location.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE18::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
<tr>
 <td><span class="code">beam::MISTAKE18::compare_function(type)</span>
 <td><span class="val">function</span>
 <td>Complaint will be issued when comparing expressions of the given type and the 
 complaint will suggest the given function.
</p>
<p>
 For C and C++, this contains the <span class="code">char *</span> and <span class="code">unsigned char *</span>
 types by default, and will suggest using the <span class="function">strcmp()</span> function instead.
</p>
<p>
 For Java, this contains the following types by default, and will suggest
 using the <span class="function">equals()</span> method instead.
 <ul>
  <!-- When added to beam_attributes_java.tcl: <li>java.lang.String</li> -->
  <li>java.lang.Boolean</li>
  <li>java.lang.Byte</li>
  <li>java.lang.Character</li>
  <li>java.lang.Short</li>
  <li>java.lang.Integer</li>
  <li>java.lang.Long</li>
  <li>java.lang.Float</li>
  <li>java.lang.Double</li>
 </ul>
</tr>
</table>
</p>
<p>
Example 2:
</p>
<pre class="example">
void foo(char *string1)
{
  char *string2 = strstr(string1, &quot;xyz&quot;);
  if (string2 == NULL) ...
  if (string1 == string2) ...
}
</pre>
<p>

In Example 2 MISTAKE18 will not be issued regarding the comparison will NULL.
The complaint will be issued regarding the comparison of <span class="var">string1</span> 
and <span class="var">string2</span> 
provided enabling_policy is "always".
But it will not be issued if enabling_policy is "no_overlap".
The reason is that the function strstr() returns a pointer into the same 
memory location as string1, and it is common to compare such pointers for 
equality, not for the strings they represent.
BEAM knows about this property of strstr() because it is given such an 
attribute in tcl/beam_attributes_libc.tcl.
For more information about attributes
see 
<a href="attributes.html">information about attributes</a>.
</p>
<p>
Example 3:
</p>
<pre class="example">
set  &quot;beam::MISTAKE18::compare_function(char *)&quot;           &quot;strcmp&quot;
set  &quot;beam::MISTAKE18::compare_function(unsigned char *)&quot;  &quot;strcmp&quot;
set  &quot;beam::MISTAKE18::compare_function(String)&quot;           &quot;String_compare&quot;
</pre>
<p>

These settings will cause the complaint when comparing 
two expressions of type <span class="code">char *</span>, or 
two expressions of type <span class="code">unsigned char *</span>, or 
two expressions of type <span class="code">String</span>.
The values <span class="function">strcmp</span>, <span class="function">String_compare</span>
will be used in the wording of the complaint,
but need not actually exist as functions; they just need to be non-empty strings.
</p>
<p>
With the above setting the complaint will also be issued for expressions
of type <span class="code">const char *</span>, <span class="code">volatile String</span>, etc.
In general, specifying a <span class="code">compare_function(T)</span> 
will also apply to all types derived from <span class="var">T</span> by adding any of the 
qualifiers <span class="code">const</span>, <span class="code">volatile</span>, <span class="code">restrict</span>.
</p>
<p>
Example 4: Suppose 
</p>
<pre class="example">
typedef   String  T;
</pre>
<p>

Then the complaint will be issued when comparing expressions of type <span class="var">T</span> in addition to 
expressions of type <span class="code">String</span>.
</p>
<p>
If there are two settings to the same type
</p>
<pre class="example">
set  &quot;beam::MISTAKE18::compare_function(T)&quot;    &quot;F1&quot;
set  &quot;beam::MISTAKE18::compare_function(T)&quot;    &quot;F2&quot;
</pre>
<p>

Then the last one will take effect.
This allows you to override previous settings, including those in 
beam_default_parms.tcl.
For example, with the above settings <span class="function">strcmp</span> is the compare function
for <span class="code">char *</span>, <span class="code">const char *</span>, 
<span class="code">unsigned char *</span>, <span class="code">const unsigned char *</span>.
However, suppose we add
</p>
<pre class="example">
set  &quot;beam::MISTAKE18::compare_function(const char *)&quot;          &quot;strncmp&quot;
set  &quot;beam::MISTAKE18::compare_function(const unsigned char *)&quot; &quot;&quot;
</pre>
<p>

Then the compare function for <span class="code">const char *</span> changes to 
<span class="function">strncmp</span>
and the compare function for <span class="code">const unsigned char *</span> changes to 
the empty string,
which will prevent the complaint for <span class="code">const unsigned char *</span>.
</p>
<p>
Example 5:
</p>
<pre class="example">
set  &quot;beam::MISTAKE18::compare_function(java.lang.String)&quot; &quot;String::equals&quot;
</pre>
<p>

This setting will cause the complaint when comparing two expressions
of type <span class="code">java.lang.String</span>.  However, this setting is
disabled in the default settings file java_default_parms.tcl
because it is not a mistake to compare objects obtained from
<a href="http://w3.java.ibm.com/java/docs/jdk5.0/api/java/lang/String.html#intern()">intern()</a>
with the <span class="code">'=='</span> operator.  If your program
rarely calls the <span class="function">intern()</span> method, it would be useful to
enable this setting.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE19"> -->
<a name="MISTAKE19"></a><h1>MISTAKE19: Terminating \0 not copied.</h1>


You are taking advantage of a rather dangerous feature of the C language,
which is in fact disallowed in C++.
</p>
<p>
Example:
</p>
<pre class="example">
char s[2] = &quot;ab&quot;;
</pre>
<p>

In C this initializes the array `s' to the string "ab", but
there is no room for the terminating 0 character.
Therefore the terminating 0 character will not be copied into `s' and `s' will not be a legal C-string.
This is rarely intended, instead the following is intended
</p>
<pre class="example">
char s[3] = &quot;ab&quot;;
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE19::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever its conditions are met
</tr>
<tr>
 <td><span class="var">beam::MISTAKE19::enabling_policy</span>
 <td><span class="val">&quot;unterminated&quot;</span>
 <td>Complaint will be issued only if the string contains no 0 character.
 For example, it will not be issued for "a\0", or "\0b"
</tr>
<tr>
 <td><span class="var">beam::MISTAKE19::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE20"> -->
<a name="MISTAKE20"></a><h1>MISTAKE20: Exception handler for type is unreachable</h1>


The exception handler is unreachable because a previous exception
handler is masking it.
</p>
<p>
Example:
</p>
<pre class="example">
try {
  throw(...);
} catch(const char *) {
  ...
} catch(char *) { // unreachable handler
  ...
}
</pre>
<p>

Because the handler for <span class="code">const char *</span> will also catch
<span class="code">char *</span>, then the handler for <span class="code">char *</span> is
unreachable.
</p>
<p>
This complaint exists because there are special rules for catching exceptions
that allow unexpected types to be caught at unexpected times.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE21"> -->
<a name="MISTAKE21"></a><h1>MISTAKE21: For function func the following
category advisory has been issued:</h1>


The function being called has an advisory associated with it (see
<a href="attributes.html">the advisory attribute</a>). The
advisory text should explain why the advisory was issued and what
steps should be taken to avoid the advisory in the future. In most
cases, the advisory will suggest calling a different function.
</p>
<p>
The category of the advisory is a free-form string which should
describe the severity of the advisory. The category is also used
to filter out unwanted advisory messages (see below).
</p>
<p>
Example:
</p>
<pre class="example">
char buff[64];
gets(buff);
</pre>
<p>

This will print an advisory for the call to <span class="function">gets</span> because
calling <span class="function">gets</span> is unsafe, and <span class="function">fgets</span> should be used
instead.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE21::enabling_policy</span>
 <td>pattern of category names
 <td>Advisory will be printed if its category matches this pattern
</tr>
</table>
</p>
<p>
Note: If you wish to place advisory messages on constructors,
be sure to enable MISTAKE21 for things that are compiler-generated:
</p>
<pre class="example">
set beam::MISTAKE21::enabled_for_compiler_generated &quot;yes&quot;
</pre>
<p>

<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE22"> -->
<a name="MISTAKE22"></a><h1>MISTAKE22: switch does not consider all cases</h1>


</p>
<p>
Example 1:
</p>
<pre class="example">
typedef enum {A, B, C, D} E;
int foo(E e)
{
  switch(e) {
   case A: return 1;
   case B: return 2;
  }
  return 0;
}
</pre>
<p>

BEAM will issue the following complaint
</p>
<pre class="example">
&quot;foo.c&quot;, line 20: switch does not consider all cases

 Missing C, D
</pre>
<p>

MISTAKE22 is meant to support the following policy toward default clauses in switch statements.
</p>
<p>
(I) If you intentionally did not list all possibilities and you do want the switch 
statement to have no effect for the omitted cases, then clarify your intention by
</p>
<pre class="example">
default: break;
</pre>
<p>

(II) If you intentionally did not list all possibilities because and you are relying 
on callers to your function <span class="code">foo(E e)</span> to pass only listed
cases, then clarify your intention by
</p>
<pre class="example">
default: abort();  /* or something like it */
</pre>
<p>

(III) If you intended to list all possibilities then omit any default clause and let
BEAM tell you if you missed something.
</p>
<p>
Example 2:
</p>
<pre class="example">
typedef enum {A, B, C, D} E;
int foo(E e)
{
  if (e == C || e == D) return 0;
  switch(e) {
   case A: return 1;
   case B: return 2;
  }
  return 0;
}
</pre>
<p>

In Example 2 all possible values of e are meant to be considered inside
the function <span class="code">foo(E e)</span> and therefore it is best to omit the default clause.
The advantage of omitting the default clause will be realized if somebody adds
another value to the enum type <span class="var">E</span>, and BEAM will be able to report
that the new value is not being handled.
</p>
<p>

<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE23"> -->
<a name="MISTAKE23"></a><h1>MISTAKE23: Result of function foo is supposed to be checked, because it has a force_test attribute</h1>


This is intended for functions with a return code or some other kind
of indication of failure.
For example, the <span class="function">fopen</span> function indicates failure by returning NULL.
Suppose that you want to require everybody to perform some recovery action 
in case <span class="function">fopen</span> fails.
Currently there is no way to tell BEAM what the correct recover action should be,
but BEAM is able to check that at least something special is done in case <span class="function">fopen</span>
returns NULL.
<!-- </snippet> -->
</p>
<p>
To enable that kind of checking for <span class="function">fopen</span>, you need to 
<ul>
<li> turn on MISTAKE23 (by setting beam::MISTAKE23::enabling_policy to "always"),
<li> make sure that "fopen" matches the <a href="parms.html#patterns">pattern</a> 
<span class="var">beam::MISTAKE23::functions</span>,
<span class="var">beam::MISTAKE23::functions_by_qualified_name</span>,
or is on the list <span class="var">beam::MISTAKE23::functions_by_signature</span>.
<li>give a <a href="attributes.html">force_test attribute</a> to <span class="function">fopen</span>.
</ul>
That attribute tells BEAM two things.
First it says that <span class="function">fopen</span>
is one of the functions for which BEAM should assume the worst 
without any further evidence.
And secondly it identifies the parameter through which the indication of failure is returned.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE23::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for a function
 whose return value identified in the force_test attribute
 is not being tested, provided the function name matches
 the function patterns below.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE23::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE23::functions</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">unqualified name</a>
 matches the pattern.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE23::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::MISTAKE23::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for functions whose
      <a href="func_name_sig.html">signature</a> is
      one in this list, even if it does not match the <span class="var">functions</span>
      pattern.
</tr>
</table>
</p>
<p>
Please see <a href="force_test.html">the Application Note</a>
for a general discussion on catching untested return codes.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE24"> -->
<a name="MISTAKE24"></a><h1>MISTAKE24: Boolean expression expr is used in a non-boolean context</h1>


This mistake is intended to catch unintentional uses of boolean values.
In some cases, the use may be unintentional because of a simple typo:
</p>
<pre class="example">
if (!x &amp; y)
</pre>
<p>

In other cases, the use may be unintentional because the wrong operator was used:
</p>
<pre class="example">
if (~(x &amp;&amp; y))
</pre>
<p>

Examine the boolean expression and the context in which it is used, and
decide if you really meant to use it in a non-boolean context.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::MISTAKE24::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>A complaint will be issued for any boolean expression
 which is used as input to one of the operations defined
 in the list <span class="var">beam::MISTAKE24::operators</span>.
</p>
<p>
 The complaint will also be issued for any boolean expression
 that is used as input to one of the operations defined
 in the list <span class="var">beam::MISTAKE24::mixed_operators</span>,
 but only if the other operand is not boolean. If both operands
 are boolean, then the complaint is not issued.
</p>
<p>
 If an operator appears in both <span class="var">operators</span> and
 <span class="var">mixed_operators</span>, then <span class="var">operators</span>
 takes precedence.
</p>
<p>
 Note that with this enabling_policy, any operator in either list
 (like "+") will include the compound-assignment form automatically
 (like "+="). To avoid this automatic inclusion, see
 enabling_policy="exact_operators".
 </td>
</tr>
<tr>
 <td><span class="var">beam::MISTAKE24::enabling_policy</span>
 <td><span class="val">&quot;exact_operators&quot;</span>
 <td>This is the same as enabling_policy="always" except that basic
 operators in either list (like "+") do NOT automatically include the
 compound-assignment form (like "+="). You have to include both operators
 in the lists explicitly if you want complaints about both. This gives
 finer control over which expressions might yield complaints. To
 automatically include the compound-assignment operators, see
 enabling_policy="always".
 </td>
</tr>
<tr>
 <td><span class="var">beam::MISTAKE24::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.</td>
</tr>
<tr>
 <td><span class="var">beam::MISTAKE24::operators</span>
 <td>list of operators
 <td>Complaint will be issued for boolean expressions
 which are used as input to operators that appear in
 this list. Available operator symbols include:
</p>
<pre class="example">
&lt; &gt; &lt;= &gt;= &lt;? &gt;? &lt;&lt; &gt;&gt; &amp; | ~ ^ / + - * % []
</pre>
<p>

 (and any compound forms of the above: "|=", etc).
</p>
<p>
 The default list contains:
</p>
<pre class="example">
&lt; &gt; &lt;= &gt;= &lt;? &gt;? &amp; | ~ ^ / * %
</pre>
<p>

 </td>
</tr>
<tr>
 <td><span class="var">beam::MISTAKE24::mixed_operators</span>
 <td>list of operators
 <td>Complaint will be issued for boolean expressions
 which are used as input to operators that appear in
 this list as long as the other operand to the operator
 does not also have boolean type. Available operator symbols
 are the same as for <span class="var">operators</span>.
</p>
<p>
 The default list is empty.
 </td>
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "MISTAKE25"> -->
<a name="MISTAKE25"></a><h1>MISTAKE25: Pointer out of range</h1>


This complaint is followed by a path though the program.
The paths ends in pointer addition, e.g., <span class="code">p + i</span>,
and the result of the addition is an address beyond the allocated memory into 
which p is pointing.
</p>
<p>
Example 1:
</p>
<pre class="example">
int a[5];
int *x = a + 10;  /* same as x = &amp;(a[10]) */
int *y = a + 5;   /* same as y = &amp;(a[5])  */
</pre>
<p>

Forming an address outside allocated memory will not cause a failure by itself,
but it is an indication of something unintended.
There is no use for such an address; 
the only exception is a pointer pointing just beyond allocated memory to be 
used in comparison
with other pointers.
In the above example, <span class="var">y</span> could be useful for checking whether 
another pointer 
exceeds the array <span class="var">a</span>.
For that reason a common configuration of MISTAKE25 would flag the assignment 
to <span class="var">x</span>, but not the assignment to <span class="var">y</span>.
<!-- </snippet> -->
</p>
<p>
BEAM assumes a memory model where all allocations (on heap as well as stack) 
are independent of each other.
It may issue MISTAKE25 if you are assuming allocations are not independent,
such as assuming that memory is allocated consecutively.
</p>
<p>
The value of <span class="var">enabling_policy</span> is a 
<a href="parms.html#patterns">pattern</a>,
whose terms are "negative_bound", "lower_bound", "upper_bound", and
"excessive_bound".
This table refers to a pointer addition <span class="code">p+i</span>, where
the pointer <span class="var">p</span> is pointing into some allocated memory
between addresses <span class="var">a</span> and <span class="var">b</span>, inclusive.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::MISTAKE25::enabling_policy</span>
 <td><span class="val">&quot;negative_bound&quot;</span>
 <td>Complaint will be issued when the pointer addition <span class="code">p+i</span>
results in an address less than <span class="var">a</span>.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE25::enabling_policy</span>
 <td><span class="val">&quot;lower_bound&quot;</span>
 <td>Complaint will be issued when the pointer addition <span class="code">p+i</span>
results in an address less than <span class="var">a</span>, or address less than 
<span class="var">p</span>, and the relation between <span class="var">p</span> and <span class="var">a</span>
cannot be determined.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE25::enabling_policy</span>
 <td><span class="val">&quot;upper_bound&quot;</span>
 <td>Complaint will be issued when the pointer addition <span class="code">p+i</span>
results in an address greater than <span class="var">b</span>.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE25::enabling_policy</span>
 <td><span class="val">&quot;excessive_bound&quot;</span>
 <td>Complaint will be issued when the pointer addition <span class="code">p+i</span>
results in an address greater than <span class="code">b+1</span>.
</tr>
<tr>
 <td><span class="var">beam::MISTAKE25::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span> 
 <td>Any of the above
</tr>
</table>
</p>
<p>
Example 2:
</p>
<pre class="example">
int a[5];
int *x;

void f(int *p)
{
  x = a - 1;    /* complaint if enabled negative_bound or lower_bound */
  x = a + 4;    /* no complaint */
  x = a + 5;    /* complaint if enabled upper_bound */
  x = a + 6;    /* complaint if enabled upper_bound or excessive_bound */
  x = p - 1;    /* complaint if enabled lower_bound */
</pre>
<p>

MISTAKE25 is a less serious version of ERROR7.
Therefore in the common situation where both could be issued 
(and beam::avalance_prevention is turned on) only ERROR7 will be issued.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING1"> -->
<a name="WARNING1"></a><h1>WARNING1: Value of static variable xyz with file scope is never used</h1>


The value of the static variable <span class="var">xyz</span> is never used, which is 
sometimes an indication of forgotten functionality.
</p>
<p>
This complaint is issued very conservatively;
it will not be issued if the address of the variable is ever taken (i.e. &xyz),
as that might lead to using its value.
</p>
<p>
You should check any code that is supposed to be using this variable,
and ensure that it is indeed being used. Make sure there are no local
variables with the same name that could be "shadowing" this global,
and make sure that the paths of code that use this variable are
reachable. 
<!-- </snippet> -->
</p>
<p>
WARNING1 is analogous to WARNING2; the difference being that 
WARNING1 is for static variables outside of any function and WARNING2 is 
for variables declared inside a function.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING1::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for static variables
     whose value is never used.
</tr>
<tr>
 <td><span class="var">beam::WARNING1::enabling_policy</span>
 <td><span class="val">&quot;assigned&quot;</span>
 <td>Complaint will be issued only for variables assigned somewhere in the 
     file.
</tr>
<tr>
 <td><span class="var">beam::WARNING1::enabling_policy</span>
 <td><span class="val">&quot;initialized&quot;</span>
 <td>Complaint will be issued only for variables explicitly initialized as part of their 
     declaration.
</tr>
<tr>
 <td><span class="var">beam::WARNING1::enabling_policy</span>
 <td><span class="val">&quot;assigned_initialized&quot;</span>
 <td>Complaint will be issued only for variables either assigned or explicitly initialized.
</tr>
<tr>
 <td><span class="var">beam::WARNING1::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
<tr>
 <td><span class="var">beam::WARNING1::disabled_variables</span>
 <td><a href="parms.html#patterns">pattern</a> of variable names
 <td>Complaint will be suppressed for variables whose name (see below)
     matches the pattern.
</tr>
</table>
</p>
<p>
To obtain the name of a variable, add <span class="option">--beam::list-all-variables</span>
to your command line and find the one you want to suppress. 
You will notice that the name of the variable will look
similar to this example: <span class="val">foo.c|varname</span>. 
RCS and SCCS users can take advantage of the wildcard notation and suppress
complaints about <span class="strong">all</span> their ID variables like so:
</p>
<pre class="example">
set beam::WARNING1::disabled_variables &quot;*|RCSid&quot;
</pre>
<p>

<br>
<br>
</p>
<p>
<!-- <snippet "WARNING2"> -->
<a name="WARNING2"></a><h1>WARNING2: Value of variable xyz with local scope is never used</h1>


The value of the variable <span class="var">xyz</span> is never used, which is sometimes 
an indication of forgotten functionality.
</p>
<p>
This complaint is issued very conservatively;
it will not be issued if the address of the variable is ever taken (i.e. &xyz),
as that might lead to using its value.
</p>
<p>
You should check any code that is supposed to be using this variable,
and ensure that it is indeed being used. Make sure there are no local
variables with the same name that could be "shadowing" this variable,
and make sure that the paths of code that use this variable are
reachable.
<!-- </snippet> -->
</p>
<p>
WARNING2 is analogous to WARNING1; the difference being that 
WARNING1 is for static variables outside of any function and WARNING2 is 
for variables declared inside a function.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING2::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for variables declared inside a function
     whose value is never used.
</tr>
<tr>
 <td><span class="var">beam::WARNING2::enabling_policy</span>
 <td><span class="val">&quot;assigned&quot;</span>
 <td>Complaint will be issued only for variables assigned somewhere in the 
     function.
</tr>
<tr>
 <td><span class="var">beam::WARNING2::enabling_policy</span>
 <td><span class="val">&quot;initialized&quot;</span>
 <td>Complaint will be issued only for variables explicitly initialized as part of their 
     declaration.
</tr>
<tr>
 <td><span class="var">beam::WARNING2::enabling_policy</span>
 <td><span class="val">&quot;assigned_initialized&quot;</span>
 <td>Complaint will be issued only for variables either assigned or explicitly initialized.
</tr>
<tr>
 <td><span class="var">beam::WARNING2::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
<tr>
 <td><span class="var">beam::WARNING2::disabled_variables</span>
 <td><a href="parms.html#patterns">pattern</a> of variable names
 <td>Complaint will be suppressed for variables whose name (see below)
     matches the pattern.
</tr>
</table>
</p>
<p>
To obtain the name of a variable, add <span class="option">--beam::list-all-variables</span>
to your command line and find the one you want to suppress. 
You will notice that the name of the variable will look
similar to this example: <span class="val">function_name|varname|1</span>. This somewhat
unusual notation is required because there can be more than one local
variable with the same name in a given function. And we need to be able to
tell them apart.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING3"> -->
<a name="WARNING3"></a><h1>WARNING3: Value of parameter xyz is never used</h1>


The value of the parameter <span class="var">xyz</span> is never used, which is sometimes an indication
of forgotten functionality.
</p>
<p>
This check is issued very conservatively;
it will not be issued if the address of the parameter is ever taken (i.e. &xyz),
as that might lead to using its value.
</p>
<p>
You should check any code that is supposed to be using this variable,
and ensure that it is indeed being used. Make sure that the paths of
code that use this variable are reachable.
</p>
<p>
This complaint may be issued under some unexpected circumstances, for example
</p>
<pre class="example">
int foo(char c)
{
  return c == EOF;
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING3::disabled_variables</span>
 <td><a href="parms.html#patterns">pattern</a> of parameter names
 <td>Complaint will be suppressed for parameters whose name (see below)
     matches the pattern.
</tr>
</table>
</p>
<p>
To obtain the name of a parameter, add <span class="option">--beam::list-all-variables</span>
to your command line and find the one you want to suppress. 
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING4"> -->
<a name="WARNING4"></a><h1>WARNING4: Possible inefficiency when passing parameter parm</h1>


<h1>WARNING4: Possible inefficiency when returning from func</h1>

Declaring a function that takes in a structure as a parameter or that
returns a structure by value is inefficient because every invocation
will copy all of the structure's fields.
</p>
<p>
Example:
</p>
<pre class="example">
struct CC
{
  ...
};

void f(struct CC xyz);

struct CC g(void);
</pre>
<p>

In this example, every call to <span class="function">f()</span> and <span class="function">g()</span>
involves copying all of the fields of <span class="code">struct CC</span>. It is
usually much more efficient to declare the function to take in or return
an address or a reference to the structure instead.
</p>
<p>
In C++, passing objects in this fashion may involve calls to the
<span class="term">copy constructor</span> of the class. This can also lead to
inefficiencies.
<!-- </snippet> -->
</p>
<p>
The value of <span class="var">enabling_policy</span> is a <a href="parms.html#patterns">pattern</a>,
whose terms are "inlined", "parameter", and "return".
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING4::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for parameters or return types whose size exceeds the
     value of <span class="var">threshold_in_bytes</span>.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::enabling_policy</span>
 <td><span class="val">&quot;inlined&quot;</span>
 <td>Complaint will be issued if the function to which the parameter or
     return type belongs was declared <span class="code">inline</span> or <span class="code">__inline__</span>.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::enabling_policy</span>
 <td><span class="val">&quot;parameter&quot;</span>
 <td>Complaint will be issued for parameters which are too large.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::enabling_policy</span>
 <td><span class="val">&quot;return&quot;</span>
 <td>Complaint will be issued for return types which are too large.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::threshold_in_bytes</span>
 <td>value
 <td>
This parameter specifies the maximal number of bytes that a compound object
can have without triggering the complaint.
If the parameter is not specified then it is interpreted as 0.
The value of -1 is interpreted as sizeof(long), which is a common 
threshold of efficiency.
</tr>
<tr>
 <td><span class="var">beam::WARNING4::disabled_types</span>
 <td><a href="parms.html#patterns">pattern of type names</a>
 <td>Complaint will be suppressed for types matching the pattern
</tr>
</table>
</p>
<p>
Here are some example policies:
</p>
<pre class="example">
set beam::WARNING4::enabling_policy &quot;always&quot; 
set beam::WARNING4::enabling_policy &quot;always - inlined - return&quot;
set beam::WARNING4::enabling_policy &quot;parameter + inlined&quot;
set beam::WARNING4::enabling_policy &quot;&quot;
</pre>
<p>

Please keep in mind that different compilers may allocate different amounts 
of memory for the same compound object.
</p>
<p>
The parameter <span class="var">disabled_types</span> can be used to suppress
the complaint for specific types only. For the example above, the
following setting will make the complaint go away:
</p>
<pre class="example">
set beam::WARNING4::disabled_types &quot;struct CC&quot;
</pre>
<p>

<br>
<br>
</p>
<p>
<!-- <snippet "WARNING5"> -->
<a name="WARNING5"></a><h1>WARNING5: Operator = in the boolean expression should possibly be ==</h1>


This potential typo can result in drastically different results,
and can be difficult to track down. Using <span class="code">=</span> when
<span class="code">==</span> was meant will lead to the boolean result being the
value of the right hand side, instead of a test for equality.
</p>
<p>
This complaint would be issued in the following example
</p>
<pre class="example">
if (foo = bar)
</pre>
<p>

The if statement performs an assignment to <span class="var">foo</span>, which should 
possibly be a mere comparison.
On the other hand, it might have been really intended as an assignment 
followed by testing <span class="code">foo != 0</span>.
</p>
<p>
BEAM allows differentiation among three possibilities:
<UL>
<LI> Right hand side is constant; here are three examples
</p>
<pre class="example">
if (a = 5)
if (a = SOME_DEFINED_CONSTANT)
if (a = &amp;b)
</pre>
<p>

This possibility is very unlikely intended, because the if condition would be always true
(or always false if the right hand side were the constant 0).
</p>
<p>
<LI> Right hand side is memory access; here are two examples
</p>
<pre class="example">
if (a = b)
if (a = b-&gt;x.y)
</pre>
<p>

This possibility is more likely intended.
</p>
<p>
<LI> Right hand side is some computation, which covers all the remaining situations;
here are two examples
</p>
<pre class="example">
if (a = b+c)
if (a = f(b))
</pre>
<p>

This possibility is most likely intended.
</UL>
</p>
<p>
Decide if you meant for this to be an assignment (with the boolean
result being the value of the right hand side), or a real test
for equality. If this should remain an assignment, consider changing
something like:
</p>
<pre class="example">
if(a = b)
</pre>
<p>

to:
</p>
<pre class="example">
if((a = b) != 0)
</pre>
<p>

The intentions are made clear, and beam will not warn about this.
<!-- </snippet> -->
</p>
<p>
The user can control which of these possibilities he wants to have reported:
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING5::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for all three possibilities.
</tr>
<tr>
 <td><span class="var">beam::WARNING5::enabling_policy</span>
 <td><span class="val">&quot;access&quot;</span>
 <td>Complaint will be issued in case right hand side is constant 
     or memory access.
</tr>
<tr>
 <td><span class="var">beam::WARNING5::enabling_policy</span>
 <td><span class="val">&quot;constant&quot;</span>
 <td>Complaint will be issued only in case right hand side is constant.
</tr>
<tr>
 <td><span class="var">beam::WARNING5::enabling_policy</span>
 <td><span class="val">&quot;gcc_convention&quot;</span>
 <td>Complaint will be issued for all three possibilities, unless the 
     assignment is surrounded by extra pair of parentheses.
     (This option is not supported for Java)
</tr>
<tr>
 <td><span class="var">beam::WARNING5::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span>
 <td>Complaint will never be issued.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING6"> -->
<a name="WARNING6"></a><h1>WARNING6: Expression xyz has a value not allowed for its type type</h1>


An integer value is assigned to an object, but the value is outside the domain of
values for the object's type.
</p>
<p>
Examples:
</p>
<pre class="example">
unsigned char uc;
signed   char sc;

......

sc = uc + 100000;
</pre>
<p>

Independent of what <span class="var">uc</span>'s value might be, the result of the addition
is too large for a signed character object.
</p>
<p>
Other examples include mixing integers and enums.
Casting a number to an enumeration is dangerous when the number
doesn't map to any enumeration value.
</p>
<p>
Example:
</p>
<pre class="example">
typedef enum {
  red, 
  blue,
  green
} color;

color xyz = (color) 5;
</pre>
<p>

This could be caused by casting to the wrong type, or casting the
wrong value. Or, maybe the cast is valid, and the variable should have
a value not covered by the enumeration.
</p>
<p>
By default BEAM assumes that all variables declared
to be of enumerated type can only contain values derived from the enumerators.
If the type <span class="var">color</span> does not have this property
you can declare it as such using the global parameter 
<span class="var">beam::dirty_enum</span> or <span class="var">beam::unused_enum_value</span>
<!-- </snippet> -->
(see <a href="parms.html#beam::dirty_enum">BEAM parameters</a>).
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING7"> -->
<a name="WARNING7"></a><h1>WARNING7: The cast truncates many bits into few</h1>


</p>
<p>
Example:
</p>
<pre class="example">
char c;
int  i;

c = i;
</pre>
<p>

This will cause the following complaint:
</p>
<pre class="example">
&quot;d.c&quot;, line 7:  The cast `(char)i' truncates 32 bits into 8
</pre>
<p>

This complaint is usually useful only when the loss of information
is unexpected, namely when the cast is implied by the compiler, not
written explicitly by the programmer.
Please recall that this behavior can be ensured by setting
</p>
<pre class="example">
set beam::WARNING7::enabled_for_compiler_generated  &quot;yes&quot;
set beam::WARNING7::disabled_for_user_written       &quot;yes&quot;
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
Turning on WARNING7 will result in more complaints than the similar WARNING6.
While WARNING6 is issued only when BEAM is sure that the value being cast
does not fit into the target type,
WARNING7 is issued even if the value being cast is unknown.
(Of course, WARNING7 will not be issued if it is clear that the value cast
does fit into the target type.)
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING7::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::WARNING7::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING8"> -->
<a name="WARNING8"></a><h1>WARNING8: Label is not the target of any goto</h1>


A label was found that no one uses. This is either a label that can be
deleted, or a symptom of a missing <span class="code">goto</span> that should be
using this label.
</p>
<p>
Check for any spots where someone should be using <span class="code">goto</span>
with this label. If there are no such spots, this label could be
deleted. Otherwise, something may be missing somewhere else.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING9"> -->
<a name="WARNING9"></a><h1>WARNING9: Return value of function is not used</h1>


The return value of the given function is ignored which is sometimes 
unintended. Make sure that it is safe to ignore the value in particular
if the return value might indicate an error condition.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect</tr>
<tr>
 <td><span class="var">beam::WARNING9::functions</span>
 <td><a href="parms.html#patterns">pattern</a> of function names
 <td>Complaint will be issued for functions whose
     <a href="func_name_sig.html">unqualified name</a>
     matches the pattern
</tr>
<tr>
 <td><span class="var">beam::WARNING9::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::WARNING9::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for functions whose
      <a href="func_name_sig.html">signature</a> matches
      one in this list, even if it does not match the functions
      pattern.
</tr>
</table>
</p>
<p>
Please see <a href="force_test.html">the Application Note</a>
for a general discussion on catching untested return codes.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING10"> -->
<a name="WARNING10"></a><h1>WARNING10: assert statement might have side-effect</h1>


Invoking functions or using expressions that have side-effects from
macros that could be compiled out (like <span class="function">assert</span>) is
usually incorrect because the side-effect is lost in some cases, like
when compiling optimized code.
</p>
<p>
Example:
</p>
<pre class="example">
assert(++a &gt; 0);
</pre>
<p>

The assertion might be disabled when compiling optimized executable,
and the incrementation of <span class="var">a</span> would be lost. It is better
practice to take care of expressions and function calls outside of
the macro, save the result in a temporary, and then assert a
simple equality or inequality.
</p>
<p>
This warning is issued for any function invoked from an assert,
even if that function actually has no side-effect.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING11"> -->
<a name="WARNING11"></a><h1>WARNING11: goto statement considered harmful</h1>


See <a href="http://www.acm.org/classics/oct95/">this classic paper</a>
for some ammunition to enable this warning.
Read Donald Knuth, <span class="strong">Structured Programming with goto Statements</span>,
Computing Surveys 6 (4), pp. 261-301, December 1974 to argue for
disabling this warning.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING12"> -->
<a name="WARNING12"></a><h1>WARNING12:  Expression is cast into signed from unsigned</h1>


</p>
<p>
Example:
</p>
<pre class="example">
long long negate(unsigned c)
{
  return -c;
}
</pre>
<p>

This will produce the following complaint for ILP32 targets:
</p>
<pre class="example">
Expression `(long long) -c' is cast into signed 64 bits from unsigned 32 bits
</pre>
<p>

This complaint is issued in situations where most peoples' expectation of 
casting effects differs from the official definition.
In the above example suppose that the variable <span class="var">c</span> has the value 1.
Most people would expect a return value of -1, but the function will in fact
return 4294967295.
</p>
<p>
The reason is as follows. Since <span class="var">c</span> has type <span class="code">unsigned int</span>, so does
<span class="code">-c</span>. Because of the wrap-around semantics of unsigned arithmetic
the value of <span class="code">-c</span> on a 32 bit machine is 4294967295.
That number is then cast into a 64 bit <span class="code">long long</span> as is.
</p>
<p>
The recommended fix is: 
</p>
<pre class="example">
return -(long long)c;
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
This complaint is issued conservatively in situations where we expect human 
expectations to differ from reality.
For example, the complaint would not be issued in case of 
</p>
<pre class="example">
long long whatever(unsigned c)
{
  return c;
}
</pre>
<p>

In general the complaint is issued only when casting the result of an 
arithmetic operation.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING13"> -->
<a name="WARNING13"></a><h1>WARNING13: Function foo is never used</h1>


The static function <span class="function">foo</span> is declared but never called, which is sometimes an indication
of forgotten functionality.
</p>
<p>
Because the function is static, no one outside of this file can call
it. This could be the symptom of a typo (perhaps it was meant to be
called from within this file). This could also be a function that was
meant to be used, but never was, or a function that used to be
used, but no longer is.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING14"> -->
<a name="WARNING14"></a><h1>WARNING14: Comparing e1 of type t1 with e2 of type t2</h1>


<h1>WARNING14: Comparing e1 of type t1 with switch expression e2 of type t2</h1>

<h1>WARNING14: Assigning e1 of type t1 to e2 of type t2</h1>

<h1>WARNING14: Passing e1 of type t1 to parameter p of f having type t2</h1>

<h1>WARNING14: Initializing x of type t1  with expression of type t2</h1>

Consider the following motivational example:
</p>
<pre class="example">
typedef float time;
typedef float length;

time T;        // in seconds
length L;      // in meters

if (T == L) ....      // complaint
</pre>
<p>

BEAM complains here, because you're comparing a length against something
that is considered 'time'. That does not seem sensible. You get the idea.
</p>
<p>
Note, that the example compiles just fine. The reason is that
<span class="var">time</span> and <span class="var">length</span> are <span class="strong">not</span> different types.
They are only synonyms for <span class="code">float</span> and therefore compilers
keep quiet about it. BEAM however treats
<span class="var">time</span> and <span class="var">length</span> as <span class="strong">different</span> types,
intentionally, because that is sometimes what was intended with the
typedef.
</p>
<p>
The complaint can occur in comparisons,  assignments, initializations (which
includes passing arguments to functions).
It involves two types and both types must either be enum types or defined
via typedef.
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::WARNING14::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever applicable.
</tr>
<tr>
 <td><span class="var">beam::WARNING14::enabling_policy</span>
 <td><span class="val">&quot;enum_enum&quot;</span>
 <td>Complaint will be issued only when both types are enum.
</tr>
<tr>
 <td><span class="var">beam::WARNING14::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
<tr>
 <td><span class="var">beam::WARNING14::disabled_types</span>
 <td><a href="parms.html#patterns">pattern of type names</a>
 <td>Complaint will be suppressed for types matching the pattern
</tr>
</table>
</p>
<p>
Set enabling_policy to "always" only if you do mean to enforce a particular 
coding style --
namely, typedefs are used to define types (e.g. <span class="var">length</span>,
<span class="code">time_t</span>) that should not be mixed,
although they have the same identical underlying type.
If you do not follow such coding style then the setting of "always" will
produce too many invalid complaints.
</p>
<p>
In contrast, just about everybody should be able to set enabling_policy 
to "enum_enum" 
because mixing two different enum types is almost never intended.
</p>
<p>
The parameter <span class="var">disabled_types</span> can be used to suppress
the complaint for specific types only. For the example above
<span class="code">set beam::WARNING14::disabled_types=&quot;time&quot;</span> will make
the complaint go away. Note, that it is not necessary to also disable
the type <span class="var">length</span>. It is sufficient if one of the participating
types is disabled and the complaint will no longer be issued.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING15"> -->
<a name="WARNING15"></a><h1>WARNING15: The then clause is not surrounded by braces</h1>


<h1>WARNING15: The else clause is not surrounded by braces</h1>

<h1>WARNING15: The loop body is not surrounded by braces</h1>

</p>
<p>
Example:
</p>
<pre class="example">
if (a)
  a = 0;
</pre>
<p>

Some coding guidelines disallow this form and require that the 
then clause be surrounded by braces, as in
</p>
<pre class="example">
if (a) {
  a = 0;
}
</pre>
<p>

This is to prevent a common mistake of the form 
</p>
<pre class="example">
if (a)
  a = 0;
  b = 0;
</pre>
<p>

Here the programmer probably meant to make the added assignment
<span class="code">b = 0</span> to be conditional, but it is unconditional.
</p>
<p>
Same rules apply to else clauses and loop bodies.
</p>
<p>
Some coding guidelines do not require the braces if the clause
is on the same line as the condition, as in
</p>
<pre class="example">
if (a) a = 0;
</pre>
<p>

The reason is that this form will not lead to the above mistake.
Therefore the beam::WARNING15::enabling policy can be "next_line",
in which case the complaint will be issued only if the 
clause (<span class="code">a = 0;</span>) terminates below the last line 
of the previous construct.
The previous construct can be <span class="code">if(a)</span>
or <span class="code">else</span> or <span class="code">while(a)</span>, etc.
<!-- </snippet> -->
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::WARNING15::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued whenever a then-clause or else-clause or loop body is not surrounded by braces.
</tr>
<tr>
 <td><span class="var">beam::WARNING15::enabling_policy</span>
 <td><span class="val">&quot;same_line&quot;</span>
 <td>Complaint will be issued only if a clause without braces appears on the same line as preceding construct.
</tr>
<tr>
 <td><span class="var">beam::WARNING15::enabling_policy</span>
 <td><span class="val">&quot;next_line&quot;</span>
 <td>Complaint will be issued only if a clause without braces appears below the line of preceding construct.
</tr>
<tr>
 <td><span class="var">beam::WARNING15::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
CAUTION: Currently, this check will only work for the C, C++, and Java languages.
It has been disabled for PL8 because of limitations of the GCC parser that is
used to read PL8 code.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING16"> -->
<a name="WARNING16"></a><h1>WARNING16: Function foo accesses the same variable through two parameters</h1>


Each of the two given parameters is either a pointer or a reference,
and both are given the address of the same variable.
This is dangerous because inside the function <span class="function">foo</span> that variable is accessed under
two separate parameters.
</p>
<p>
Example:
</p>
<pre class="example">
scanf(&quot;%d %d&quot;, &amp;x, &amp;x);
</pre>
<p>

This will yield the complaint
</p>
<pre class="example">
&quot;foo.C&quot;, line 5: Function `scanf' accesses the same variable `x' through two parameters #2 and #3
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
The user can limit the applicability of this check through 
<span class="var">beam::WARNING16::enabling_policy</span>, which is a 
<a href="parms.html#patterns">pattern</a>
with elements
<span class="var">like_scanf</span> and <span class="var">explicitly_given</span>.
And in the case of <span class="var">explicitly_given</span>, 
<span class="var">beam::WARNING16::functions</span> and
<span class="var">beam::WARNING16::functions_by_qualified_name</span>
give <a href="parms.html#patterns">patterns</a>
of function names for which the check is to apply
and <span class="var">beam::WARNING16::functions_by_signature</span>
gives a list of function signatures for which the check
is to apply.
The check will apply if a function matches any of those parameters.
</p>
<p>
<table>
<tr>
 <th align=left>Parameter
 <th align=left>Value
 <th align=left>Effect
</tr>
<tr>
 <td><span class="var">beam::WARNING16::enabling_policy</span>
 <td><span class="val">&quot;like_scanf&quot;</span>
 <td>Complaint will be issued for all functions with 
 <a href="attributes.html">attribute</a> <span class="code">format</span> and <span class="code">kind = scanf</span>
</tr>
<tr>
 <td><span class="var">beam::WARNING16::enabling_policy</span>
 <td><span class="val">&quot;explicitly_given&quot;</span>
 <td>Complaint will be issued for all functions whose name matches the pattern in 
 beam::WARNING16::functions OR whose qualified name matches the pattern in
 beam::WARNING16::functions_by_qualified_name OR whose signature is on the list
 beam::WARNING16::functions_by_signature.
</tr>
<tr>
 <td><span class="var">beam::WARNING16::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued under either of the conditions above
</tr>
<tr>
 <td><span class="var">beam::WARNING16::enabling_policy</span>
 <td><span class="val">&quot;&quot;</span> 
 <td>Complaint will never be issued
</tr>
<tr>
 <td><span class="var">beam::WARNING16::functions</span>
 <td><a href="parms.html#patterns">pattern of function names</a>
 <td>Complaint will be issued for all functions whose
     <a href="func_name_sig.html">unqualified name</a>
     matches the pattern, provided <span class="var">beam::WARNING16::enabling_policy</span>
     allows <span class="val">explicitly_given</span>.
</tr>
<tr>
 <td><span class="val">beam::WARNING16::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::WARNING16::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for all functions whose
      <a href="func_name_sig.html">signature</a> is
      on this list, provided <span class="var">beam::WARNING16::enabling_policy</span>
     allows <span class="val">explicitly_given</span>.
</tr>
</table>
</p>
<p>
Example:
</p>
<pre class="example">
set beam::WARNING16::enabling_policy &quot;like_scanf&quot;
set beam::WARNING16::functions  &quot;* - *printf&quot;
</pre>
<p>

The complaint will be issues for all functions like scanf.
(The setting of <span class="var">beam::WARNING16::functions</span>
has no effect).
</p>
<p>
Example:
</p>
<pre class="example">
set beam::WARNING16::enabling_policy &quot;explicitly_given&quot;
set beam::WARNING16::functions  &quot;* - *printf&quot;
</pre>
<p>

The complaint will be issues for all functions except 
<span class="function">printf, sprintf</span>, etc.
</p>
<p>
Example:
</p>
<pre class="example">
set beam::WARNING16::enabling_policy  &quot;always&quot;
set beam::WARNING16::functions  &quot;foo bar&quot;
set beam::WARNING16::functions_by_qualified_name  &quot;ns::baz&quot;
</pre>
<p>

The complaint will be issues for all functions like scanf
plus the two functions <span class="function">foo, bar, and ns::baz</span>.
</p>
<p>
Example:
</p>
<pre class="example">
set     beam::WARNING16::enabling_policy        &quot;always&quot;
set     beam::WARNING16::functions              &quot;* - *printf&quot;
lappend beam::WARNING16::functions_by_signature { clas::my_printf(const char *, ...) }
</pre>
<p>

The complaint will be issues for all functions except 
<span class="function">printf, sprintf</span>, etc. However, the single
function whose signature is
<span class="code">clas::my_printf(const char *, ...)</span> will
also be considered for complaints, since it is listed
in the <span class="var">functions_by_signature</span> list. Even
though <span class="function">my_printf</span> is excluded by the
pattern, a function only has to match one of the
parameters (either the patterns or the list of signatures)
to be included in the complaints.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING17"> -->
<a name="WARNING17"></a><h1>WARNING17: xyz already contains the value being assigned</h1>


Higher in the code the variable <span class="var">xyz</span> was already assigned this value.
This could be caused by misspelling the variable name in one of the
assignments, assigning the wrong value, or just by being extra careful
to make sure that xyz will have that value.
</p>
<p>
Look at the previous assignment to <span class="var">xyz</span> and determine if the
current assignment is necessary. It may need to be changed because it
is incorrect, or it may be unnecessary all together.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING18"> -->
<a name="WARNING18"></a><h1>WARNING18: class_name object is being copied with a compiler-generated copy constructor</h1>


</p>
<p>
Example:
</p>
<pre class="example">
class widget 
{
  /* some class definition without copy constructor or assignment operator */
};
...
widget new_w = new widget(old_w);
</pre>
<p>

The above code creates a new instance <span class="var">new_w</span>
initialized to a copy of <span class="var">old_w</span>.
Given that the class <span class="var">widget</span> has no copy constructor,
a compiler-generated copy constructor will be invoked,
which copies each member.
That may be unintended and can cause serious problems,
for example, if the class has a destructor freeing memory 
created by a constructor.
</p>
<p>
For the above code you would get the complaint
</p>
<pre class="example">
&quot;foo.C&quot;, line 42: widget `old_w' is being copied with a compiler-generated copy constructor
</pre>
<p>

If you do know that <span class="var">widget</span> can be safely copied with the 
compiler-generated copy constructor
then you can indicate so by adding <span class="var">widget</span> to the 
<a href="parms.html#patterns">pattern</a> <span class="var">beam::WARNING18::disabled_classes</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING19"> -->
<a name="WARNING19"></a><h1>WARNING19: Beware, strcmp is true if the arguments differ</h1>


Since <span class="function">strcmp</span> returns <span class="code">0</span> (<span class="code">false</span>)
if the arguments are the same, the expected result is sometimes incorrect.
</p>
<p>
Example:
</p>
<pre class="example">
if(strcmp(a,b))
</pre>
<p>

This <span class="code">if</span> statement may appear to check if the arguments are
the same, but it will only succeed if they are different. To avoid
this misunderstanding a coding guideline may require that the
if-statement be written as:
</p>
<pre class="example">
if(strcmp(a,b) == 0)
</pre>
<p>

which succeeds when the arguments are the same, or
</p>
<pre class="example">
if(strcmp(a,b) != 0)
</pre>
<p>

which succeeds when they are different.
</p>
<p>
One of these options should be chosen and used, depending on whether
this <span class="code">if</span> statement was meant to check equality or inequality.
<!-- </snippet> -->
</p>
<p>
Suppose you have your own function <span class="function">foo</span> similar to <span class="function">strcmp</span> 
and you want to be warned about testing its value without explicit comparison.
In that case you can add <span class="var">foo</span> to the 
<a href="parms.html#patterns">pattern</a> of function names to be tested
like this
</p>
<pre class="example">
lappend beam::WARNING19::functions &quot;foo&quot;

# Or like this, for specifying a namespace or class member by name
lappend beam::WARNING19::functions_by_qualified_name &quot;ns::foo&quot;
</pre>
<p>

or you could add the signature to the list of function signatures to
be tested like this
</p>
<pre class="example">
lappend beam::WARNING19::functions_by_signature { clas::foo(int) }
</pre>
<p>

<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING19::functions</span>
 <td><a href="parms.html#patterns">pattern</a> of functions
 <td>Complaint will be issued for any function whose
     <a href="func_name_sig.html">unqualified name</a>
     matches the pattern
</tr>
<tr>
 <td><span class="var">beam::WARNING19::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::WARNING19::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for functions whose
      <a href="func_name_sig.html">signature</a> matches
      one in this list, even if it does not match the <span class="var">functions</span>
      pattern.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING20"> -->
<a name="WARNING20"></a><h1>WARNING20: This declaration shadows variable on line ...</h1>


<h1>WARNING20: This declaration shadows field on line ...</h1>

<h1>WARNING20: This declaration shadows method on line ...</h1>

This check warns you of variable or parameter declarations that
hide (or "shadow") other variables or parameters in enclosing scopes.
This also warns you of class field declarations and class method
declarations that hide (or "shadow") class fields and methods
in base classes.
</p>
<p>
Example:
</p>
<pre class="example">
int x;

int foo(int x)
{
  return x + 1;
}
</pre>
<p>

The parameter <span class="var">x</span> of function <span class="function">foo</span> shadows the
global variable <span class="var">x</span>.
</p>
<pre class="example">
class Parent {
public:
  int x;
};
class Child : public Parent {
public:
  int x;
};
</pre>
<p>

The field <span class="var">Child::x</span> shadows the base class field
<span class="var">Parent::x</span>.
</p>
<p>
This check will catch the shadowing of global variables, function
parameters, and local variables interchangeably. It also catches
the shadowing of class fields and class methods when defining
derived classes.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING20::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complain about all shadowing declarations, regardless of the
     setting of <span class="var">must_not_shadow</span></td>
</tr>
<tr>
 <td><span class="var">beam::WARNING20::enabling_policy</span>
 <td><span class="val">&quot;must_not_shadow&quot;</span>
 <td>Complaint will be issued for any shadow relationship that
     matches the setting of <span class="var">must_not_shadow</span>
</tr>
<tr>
  <td><span class="var">beam::WARNING20::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued
</tr>
<tr>
  <td><span class="code">beam::WARNING20::must_not_shadow(<span class="val">shadowed_category</span>)</span>
  <td><a href="parms.html#patterns">pattern of shadowing category names</a>
  <td>When <span class="var">enabling_policy</span> is <span class="val">&quot;must_not_shadow&quot;</span>, the
  complaint will only be issued if the <span class="term">category</span> of the shadowing
  variable matches the pattern given for the <span class="term">category</span> of the shadowed
  variable. Each category must be one of <span class="val">&quot;global&quot;</span>, <span class="val">&quot;parameter&quot;</span>,
  <span class="val">&quot;local&quot;</span>, <span class="val">&quot;field&quot;</span>, and <span class="val">&quot;method&quot;</span>. The
  <span class="val">&quot;global&quot;</span>, <span class="val">&quot;local&quot;</span>, and <span class="val">&quot;parameter&quot;</span> settings
  can be mixed and matched (for example, a parameter can shadow a global variable).
  The <span class="val">&quot;field&quot;</span> and <span class="val">&quot;method&quot;</span> settings are currently independent;
  only fields can shadow fields, and only methods can shadow methods.
  See below for an example.
</tr>
</table>
</p>
<p>
Note that a derived class method is not considered to shadow a base class
method if any of the following are true:
<ul>
<li>The base class method is overridden by some other method in the
    derived class. The fact that it was overridden by some other
    method implies that the author of the class knows of the method
    and is simply defining an overloaded version of it here.</li>
<li>The base class method is brought into the scope of the derived
    class via a using-declaration (like <span class="code">using Base::foo</span>).
    The fact that it was referenced this way implies that the author
    of the class knows of the method and is simply defining an
    overloaded version of it here.</li>
</ul>
</p>
<p>
This example configuration allows all shadowing complaints:
</p>
<pre class="example">
set beam::WARNING20::enabling_policy &quot;always&quot;
</pre>
<p>

This example only allows complaints where local variables shadow parameters:
</p>
<pre class="example">
set beam::WARNING20::enabling_policy &quot;must_not_shadow&quot;
set beam::WARNING20::must_not_shadow(parameter) &quot;local&quot;
</pre>
<p>

This example only allows complaints where class fields shadow base class fields:
</p>
<pre class="example">
set beam::WARNING20::enabling_policy &quot;must_not_shadow&quot;
set beam::WARNING20::must_not_shadow(field) &quot;field&quot;
</pre>
<p>

This example only allows complaints where class fields shadow base class fields:
</p>
<pre class="example">
set beam::WARNING20::enabling_policy &quot;must_not_shadow&quot;
set beam::WARNING20::must_not_shadow(method) &quot;method&quot;
</pre>
<p>

<br>
<br>
</p>
<p>
<!-- <snippet "WARNING21"> -->
<a name="WARNING21"></a><h1>WARNING21: Using the result of function as
             a boolean value may be inefficient</h1>


</p>
<p>
This check warns you if you call a function and use the result
as a boolean value (by comparing it equal or not equal to zero,
or by using it in a boolean context) because there may be a more
efficient alternative.
</p>
<p>
This may be useful for certain functions like <span class="function">strlen</span>.
Comparing the first character to the ASCII '\0' character may be
more efficient than comparing the length of the string to zero.
</p>
<p>
Example:
</p>
<pre class="example">
int foo(char *x)
{
  if (strlen(x)) {
    return 1;
  }
  return 0;
}
</pre>
<p>

Depending on your compiler, this may be inefficient.
The following can be used if efficiency is more important than clarity:
</p>
<pre class="example">
int foo(char *x)
{
  if (x[0] != '\0') {
    return 1;
  }
  return 0;
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING21::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any function that matches
     the <span class="var">functions</span> pattern below and whose
     result is compared equal to or not equal to zero, or
     is used in boolean context.
</tr>
<tr>
  <td><span class="var">beam::WARNING21::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued
</tr>
<tr>
  <td><span class="var">beam::WARNING21::functions</span>
  <td><a href="parms.html#patterns">pattern of function names</a>
  <td>When <span class="var">enabling_policy</span> is <span class="val">&quot;always&quot;</span>, complaints
      will be issued for functions whose
      <a href="func_name_sig.html">unqualified name</a> matches this pattern
</tr>
<tr>
 <td><span class="var">beam::WARNING21::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::WARNING21::functions_by_signature</span>
  <td>List of function signatures
  <td>When <span class="var">enabling_policy</span> is <span class="val">&quot;always&quot;</span>, complaints
      will be issued for functions whose
      <a href="func_name_sig.html">signature</a> matches
      one in this list, even if it does not match the <span class="var">functions</span>
      pattern.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING22"> -->
<a name="WARNING22"></a><h1>WARNING22: Boolean operator op always evaluates both operands.</h1>


</p>
<p>
This check warns you if you use the <span class="code">&amp;</span> or <span class="code">|</span>
operator on boolean values in Java code. These operators act the
same as the <span class="code">&amp;&amp;</span> and <span class="code">||</span> operators, except
that the single-character versions will always evaluate both operands,
while the double-character versions won't evaluate the right-hand
side if it doesn't have to (commonly called "short-circuiting").
</p>
<p>
Most programmers expect this short-circuit evaluation, especially
in cases where evaluating the right-hand side under certain conditions
would lead to an error:
</p>
<pre class="example">
/* Oops, programmer meant '||' */
if (o == null | o.checkFlag()) {
  ...
}
</pre>
<p>

Here is another example where the short-circuit evaluation is preferred.
The right-hand side contains a lengthy calculation:
</p>
<pre class="example">
/* Oops, programmer meant '&amp;&amp;' */
if (doLongCheck &amp; someLongCheck()) {
  ...
}
</pre>
<p>

Changing these operators to the short-circuiting operators is usually more
clear and correct. Only in very rare performance-critical code should the
single-character, non-short-circuiting boolean operators be used.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING22::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any use of the <span class="code">&amp;</span>
     or <span class="code">|</span> operator when used on boolean values.
</tr>
<tr>
  <td><span class="var">beam::WARNING22::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued
</tr>
</table>
</p>
<p>
Note that this complaint will only be issued for Java.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "WARNING24"> -->
<a name="WARNING24"></a><h1>WARNING24: Promotion of character literals.</h1>


</p>
<p>
This check warns you if you add character literals promoted to <span class="code">int</span>
in Java code in a context where a String would have also been syntactically
correct. This addition doesn't concatenate the characters like String
concatenation would, which might have been the intention.
</p>
<p>
Example:
</p>
<pre class="example">
Object o = 'a' + 'b'; /* Probably meant to be string concatenation */
</pre>
<p>

To avoid this misunderstanding this statement should be written as:
</p>
<pre class="example">
Object o = &quot;a&quot; + &quot;b&quot;;
</pre>
<p>

This check also warns you if you pass a promoted character literal to a
method which overloads another method with a String parameter, and the
method calls could be confused.
</p>
<p>
Example:
</p>
<pre class="example">
public void doWork(int x);
public void doWork(String x);
...
doWork('x'); /* Probably meant to be String literal */
</pre>
<p>

To avoid this misunderstanding this method invocation should be written as:
</p>
<pre class="example">
doWork(&quot;x&quot;); /* If you meant a String literal */

doWork((int)'c'); /* If you meant an integer value */
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::WARNING24::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any addition of the promoted character literals
     where a String value would have also compiled successfully.
</p>
<p>
     Complaint will also be issued for any promotion that results from calling
     a routine declared to take in <span class="code">int</span> when there is a routine of
     the same name declared to take in <span class="code">String</span> as well. These
     will only be issued if the called routine matches one of the function
     pattern or list parameters below.
</tr>
<tr>
  <td><span class="var">beam::WARNING24::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued
</tr>
<tr>
 <td><span class="var">beam::WARNING24::functions</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">unqualified name</a>
 matches the pattern.
</tr>
<tr>
 <td><span class="var">beam::WARNING24::functions_by_qualified_name</span>
 <td>pattern of function names
 <td>Complaint will be issued for functions whose
 <a href="func_name_sig.html">qualified name</a>
 matches the pattern.
</tr>
<tr>
  <td><span class="var">beam::WARNING24::functions_by_signature</span>
  <td>List of function signatures
  <td>Complaint will be issued for functions whose
      <a href="func_name_sig.html">signature</a> is
      one in this list.
</tr>
</table>
</p>
<p>
Note that this complaint will only be issued for Java. Also note that
by default, the following are excluded from this complaint because
the Java API for these items is overloaded for <span class="code">int</span> and
<span class="code">String</span>, and the <span class="code">int</span> form is indeed a character
(and not a number).
<ul>
  <li><span class="code">java.lang.String.indexOf()</span></li>
  <li><span class="code">java.lang.String.lastIndexOf()</span></li>
  <li><span class="code">java.io.*</span> (because many have <span class="code">.write(int)</span> and
                                            <span class="code">.write(String)</span></li>
</ul>
</p>
<p>
<br>
<br>
</p>
<p>
<hr />

</p>
<p>
<h1>Portability checks</h1>

</p>
<p>
These checks will complain about problems that will arise when 
moving code from one machine width (like a 32-bit) to
another machine width (like a 64-bit machine).
</p>
<p>
<a name="pmachine"></a><h2>The "portability target machine"</h2>


</p>
<p>
The description of the source machine for which the code
is built on currently (the "build machine") is taken directly from the
<a href="compiler_configuration.html">compiler configuration file</a> that
is being used during the BEAM run. This file describes the size of
<span class="code">int</span>, <span class="code">long</span>, pointers, etc.
</p>
<p>
The description of the target machine for the portability
checks should be done in the <a href="customize.html">custom parameter file</a>.
The following is the default, which describes a basic 64-bit machine.
One can set any or all of these values from one's configuration
file by copying the lines below and modifying them appropriately.
</p>
<pre class="example">
set  beam::portability_target::target_sizeof_bool         1
set  beam::portability_target::target_sizeof_short        2
set  beam::portability_target::target_sizeof_int          4
set  beam::portability_target::target_sizeof_long         8
set  beam::portability_target::target_sizeof_long_long    8
set  beam::portability_target::target_sizeof_pointer      8
</pre>
<p>

One can also set up sizes of typedef'd types by setting
the size of the type in the following variable.
The values here are also the default values.
</p>
<pre class="example">
set  beam::portability_target::target_sizeof_type(wchar_t)   4
set  beam::portability_target::target_sizeof_type(intptr_t)  8
set  beam::portability_target::target_sizeof_type(uintptr_t) 8
</pre>
<p>

Note that in C++, for the portability checks, we treat
<span class="code">wchar_t</span> as a typedef, so that the configuration
is consistent across C and C++.
</p>
<p>
By changing these values, one can cause BEAM to check for
portability problems when moving from the current build machine
to anything from a machine with 8-bit pointers to a machine
with 128-bit longs and beyond.
</p>
<p>
<!-- <snippet "PORTABILITY1"> -->
<a name="PORTABILITY1"></a><h1>PORTABILITY1: The cast (int) ptr will cause truncation the
portability target machine</h1>


For example, on a 64 bit machine pointers are 64 bits, while an <span class="code">int</span> is 
only 32 bits. Some casts that work in 32 bit mode will behave
differently in 64 bit mode. 
</p>
<p>
Example:
</p>
<pre class="example">
int* ptr;
...
int num = (int) ptr;
</pre>
<p>

In this example, the cast will work fine in 32 bit mode, but will
truncate the value of <span class="code">ptr</span> in 64 bit mode.
</p>
<p>
This complaint is issued whenever a pointer of a certain size on
the build machine is cast into a numeric type that is large enough
on the build machine, but would be too small on the
<a href="#pmachine">portability target machine</a>.
</p>
<p>
If casting must be done to store pointers in integer types, use a type
large enough on all targets (usually <span class="code">unsigned long</span>).
<!-- </snippet> -->
</p>
<p>
A dual complaint is PORTABILITY3.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::PORTABILITY1::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY1::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "PORTABILITY2"> -->
<a name="PORTABILITY2"></a><h1>PORTABILITY2: The cast (int) long will cause truncation on the
portability target machine</h1>


<h1>PORTABILITY2: The operation 'op' will cause truncation on the
portability target machine</h1>

For example, on a 64 bit machine <span class="code">long</span> is 64 bits, while 
<span class="code">int</span> is only 32 bits. Some casts that work in 32 bit mode
will behave differently in 64 bit mode.
</p>
<p>
Examples:
</p>
<pre class="example">
long num1;
...
int num2 = (int) num1; // Explicit cast from long to int
...
num2 += num1; // Implicit conversion from long to int
</pre>
<p>

In these examples, the conversion will work fine in 32 bit mode, but will
truncate the value of <span class="var">num1</span> or <span class="code">num1 + num2</span>
in 64 bit mode.
</p>
<p>
This complaint is issued whenever a variable of numeric type of a
certain size on the build machine is cast into a numeric type
that is large enough on the build machine, but would be too
small on the <a href="#pmachine">portability target machine</a>.
</p>
<p>
If casting must be done between integer types, use a type that is
large enough on all targets, or beware of truncation on some.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::PORTABILITY2::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY2::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "PORTABILITY3"> -->
<a name="PORTABILITY3"></a><h1>PORTABILITY3: The cast (ptr) int may behave differently
on the portability target machine</h1>


For example, on a 64 bit machine pointers are 64 bits, while <span class="code">int</span>
is only 32 bits.
Some casts that work in 32 bit mode will behave differently in 64 bit
mode.
</p>
<p>
Example:
</p>
<pre class="example">
int num;
...
int* ptr = (int*)num;
</pre>
<p>

In this example, the cast will work fine in 32 bit mode, but will pad
the result in 64 bit mode. Since the result is a pointer, and the
source type can not hold a pointer in 64 bit mode, this is almost
always incorrect.
</p>
<p>
This complaint is issued whenever a variable of numeric type of
a certain size on the build machine is cast into a pointer type,
where the numeric type is large enough on the build machine to
represent all pointer values, but would be too small on the
<a href="#pmachine">portability target machine</a>.
</p>
<p>
If casting must be done between pointers and integer types, use a type
that is large enough on all platforms (usually <span class="code">unsigned long</span>).
<!-- </snippet> -->
</p>
<p>
A dual complaint is PORTABILITY1.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::PORTABILITY3::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY3::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "PORTABILITY4"> -->
<a name="PORTABILITY4"></a><h1>PORTABILITY4: The cast (long) ptr may cause irreproducible behavior</h1>


Casting a pointer to a numeric type can cause irreproducible behavior
depending on where the address exists in memory, if that location
not deterministic.
</p>
<p>
If possible, casting pointers to numeric types should be avoided.
The complaint is issued whenever a pointer type is cast into a numeric type.
Certain numeric types can be ignored by customizing the <span class="var">disabled_types</span>
parameter.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::PORTABILITY4::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any cast from a pointer
     type to a numeric type, unless the numeric type
     matches the <span class="var">disabled_types</span> pattern below.
</tr>
<tr>
  <td><span class="var">beam::PORTABILITY4::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued.
</tr>
<tr>
  <td><span class="var">beam::PORTABILITY4::disabled_types</span>
  <td><a href="parms.html#patterns">pattern of type names</a>
  <td>When <span class="var">enabling_policy</span> is <span class="val">&quot;always&quot;</span>, complaints
      will be issued for types whose names do not match this pattern.
      By default, <span class="code">intptr_t</span> and <span class="code">uintptr_t</span> are
      in this pattern, and casting pointers to these types will not
      complained about.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY4::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY4::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "PORTABILITY5"> -->
<a name="PORTABILITY5"></a><h1>PORTABILITY5: The cast (long *) ptr_to_int may behave differently
on the portability target machine</h1>


For example, some casts that work in 32 bit mode will behave
differently in 64 bit mode.
</p>
<p>
Example:
</p>
<pre class="example">
int i;                 /* 32 bits */
long *l = (long *) &amp;i; /* l thinks it has a pointer to 64 bits */
*l = 5;                /* 64 bits starting with the address of i are being overwritten */
</pre>
<p>

In this example, the cast will work fine in 32 bit mode, but memory
will be overwritten in 64 bit mode.
</p>
<p>
This complaint is issued whenever a pointer to a type of a
certain size on the build machine is cast to a pointer to
a type that is the same size on the build machine, but would
be a different size on the
<a href="#pmachine">portability target machine</a>.
</p>
<p>
If casting must be done between numeric types, ensure that the
destination type is never larger than the source type, or memory may
be corrupted by assignments into the pointer, and invalid memory
may be read by dereferencing the pointer.
<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::PORTABILITY5::enabled_for_compiler_generated</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will (will not) be issued for compiler generated casts.
</tr>
<tr>
 <td><span class="var">beam::PORTABILITY5::disabled_for_user_written</span>
 <td><span class="val">&quot;yes&quot;</span><br><span class="val">&quot;no&quot;</span>
 <td>Complaint will not (will) be issued for casts written by the programmer.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "SECURITY1"> -->
<a name="SECURITY1"></a><h1>SECURITY1: String pat is used as a pattern for printf</h1>


</p>
<p>
Example:
</p>
<pre class="example">
printf(pat);
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
String 'pat' is used as a pattern for `printf'
</pre>
<p>

If the string <span class="val">pat</span> contained any % specifications,
then printf will access whatever happens to be on the stack,
which could allow violation of security.
It is safer to code the example like this
</p>
<pre class="example">
printf(&quot;%s&quot;, pat);
</pre>
<p>

The function <span class="function">printf</span> is not the only one whose format will be checked.
BEAM will check any function's arguments for insecure format,
provided that function is given a format 
<a href="attributes.html">attribute</a>.
For an example, see the usage of  <span class="var">printf_like</span> in 
the file <span class="file">tcl/beam_attributes.tcl</span>.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "SECURITY2"> -->
<a name="SECURITY2"></a><h1>SECURITY2: Passing untrusted input to argument</h1>


</p>
<p>
Example:
</p>
<pre class="example">
void complain(char *s)
{
  strcpy(buff, s);
}
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
Passing untrusted input to argument #2 of `strcpy'
</pre>
<p>

If the string <span class="var">s</span> is longer than <span class="var">buff</span>
then some memory will be overwritten.
This can be used by an attacker to make the machine execute his code.
</p>
<p>
This complaint is related to ERROR7, which also checks for buffer overruns.
The difference lies in the amount of evidence necessary to issue the compliant.
For SECURITY2 sufficient evidence is the mere absence of any checking of length of 
<span class="var">s</span>.
That is, SECURITY2 should be turned on in code where any input string 
is assumed to be too long unless programmer checked it and determined 
that it is not too long.
In contrast, for ERROR7 the burden of proof is on BEAM to find evidence
that the input string is indeed too long.
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<hr />

</p>
<p>
<h1>Java Native Interface checks</h1>

</p>
<p>
These checks will complain about problems that are specific to Java
Native Interface (JNI) programs.  For other JNI problems which can be
detected by ERROR23 or ERROR26, see <a href="jni.html">JNI Checking
Guide</a>.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "JNI1"> -->
<a name="JNI1"></a><h1>JNI1: JNI invalid local reference</h1>


JNI1 detects <a href="http://java.sun.com/docs/books/jni/html/pitfalls.html#11231">using
invalid local references</a>.<br>
</p>
<p>
Example:
</p>
<pre class="example">
static jclass stringClass;
JNIEXPORT void JNICALL Java_Foo_initialize(JNIEnv *env, jclass cls)
{
  stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
}
</pre>
<p>

will generate the complaint
</p>
<pre class="example">
Assigning a local reference to a global variable
</pre>
<p>

The value assigned to <span class="var">stringClass</span> is a local reference
and native code should not store a local reference in a global
variable and expect to use it in later invocations of the native
method.
</p>
<p>
This example should be modified so it can assign a global reference like this
</p>
<pre class="example">
static jclass stringClass;
JNIEXPORT void JNICALL Java_Foo_initialize(JNIEnv *env, jclass cls)
{
  jclass tmp;
  tmp = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
  stringClass = (*env)-&gt;NewGlobalRef(env, tmp);
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
  <td><a name="JNI1::jnienv"><span class="var">jni::JNI1::jnienv</span>
  <td>the name of type to which <span class="var">JNIEnv</span> is typedef'ed
  <td>This parameter specifies <span class="var">JNIEnv</span>'s actual name,
  which BEAM needs internally. The default value, <span class="var">JNIEnv_</span>
  for C++ or <span class="var">JNINativeInterface_</span> for C, is set by
  jni_default_parms.tcl.  Unless you develop your code with IBM's or
  Sun's JDK, you may need to modify this parameter.  For example,
  assign <span class="var">JNIEnv_External</span> for Apache Harmony.
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "JNI2"> -->
<a name="JNI2"></a><h1>JNI2: JNI type error</h1>


JNI2 detects the following errors, which relate to <a href="http://java.sun.com/docs/books/jni/html/pitfalls.html#11223">passing
invalid arguments to JNI functions</a>.
</p>
<p>
<dl>
<dt>Class not found
<dd>Class name given to, for example, a call to <span class="function"><a href="http://java.sun.com/docs/books/jni/html/functions.html#52110">FindClass</a></span>
is not found in the classpath.
</p>
<p>
<dt>Method not found
<dd>Given a class, a method specified by the name
and the signature in a call to <span class="function"><a href="http://java.sun.com/docs/books/jni/html/functions.html#65238">GetMethodID</a></span>
is not found.
</p>
<p>
<dt>Field not found
<dd>Given a class, a field specified by the name
in a call to <span class="function"><a href="http://java.sun.com/docs/books/jni/html/functions.html#68548">GetFieldID</a></span>
is not found.
</p>
<p>
<dt>Type mismatch
<dd>Type of a field or a method parameter doesn't
match the class definition.
</p>
<p>
<dt>Signature format error
<dd>The signature passed to
<span class="function">GetMethodID</span> or <span class="function">GetFieldID</span> is wrong.
</p>
<p>
<dt>Wrong number of arguments
<dd>The number of arguments for a method
call function (e.g. <span class="function"><a href="http://java.sun.com/docs/books/jni/html/functions.html#87060">Call&lt;Type&gt;Method</a></span>)
is wrong.
</dl>
</p>
<p>
Example:
</p>
<pre class="example">
JNIEXPORT void JNICALL Java_Foo_initialize(JNIEnv *env, jobject arg)
{
  jclass cls = (*env)-&gt;FindClass(env, &quot;com/ibm/beam/NonexistentByConstant&quot;); /* Class not found */
  cls = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
  jfieldID fid = (*env)-&gt;GetFieldID(env, cls, &quot;xyz&quot;, &quot;I&quot;);     /* Field not found */
  jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;xyz&quot;, &quot;()I&quot;); /* Method not found */
  mid = (*env)-&gt;GetMethodID(env, cls, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);
  (*env)-&gt;CallObjectMethod(env, obj, mid, arg);                /* Wrong number of arguments */
  cls = (*env)-&gt;FindClass(env, &quot;java/awt/Point&quot;);
  fid = (*env)-&gt;GetFieldID(env, cls, &quot;x&quot;, &quot;Z&quot;);                /* Type mismatch */
  fid = (*env)-&gt;GetFieldID(env, cls, &quot;x&quot;, &quot;Lbadsignature&quot;);    /* Signature format error */
  ...
}
</pre>
<p>

<!-- </snippet> -->
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
  <td><span class="var">jni::JNI2::classpath</span>
  <td>(Semi-)colon-separated path list
  <td>This parameter specifies the classpath in which BEAM searches
  class files required by the native code. You need to set this
  parameter when you enable JNI2.
<tr>
  <td><span class="var">jni::JNI2::jnienv</span>
  <td>the name of type to which JNIEnv is typedef'ed
  <td>Same as <a href="#JNI1::jnienv">JNI1's jnienv</a>
</tr>
</table>
</p>
<p>
<br>
<br>
</p>
<p>
<hr />

</p>
<p>
<h1>Concurrency checks</h1>

</p>
<p>
These checks will complain about problems that occur only if your code
is executed by multiple threads or processes concurrently.
</p>
<p>
Some of these checks are based on locking primitives, and therefore
they need information about which locking primitives are used by your code.
At this time the BEAM installation comes with attributes for the following
primitives.
<ul>
  <li><B>pthreads:</B> You need to add "--beam::source=beam_pthread.tcl"
      to your invocation line of BEAM.
  <li><B>AIX:</B>  In general, you need to add 
      "--beam::source=beam_attributes_libc_aix.tcl"
      to your invocation line of BEAM.
      However, it is not necessary if you are running on AIX -- 
      that library is read in automatically.
  <li><B>anything else:</B> You need to write your own tcl file (with our help)
      and add its sourcing to your invocation line of BEAM.
</ul>
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "CONCURRENCY1"> -->
<a name="CONCURRENCY1"></a><h1>CONCURRENCY1: Storing into field ... modifies global shared object ...</h1>


<h1>CONCURRENCY1: Calling method ... may modify global shared object ...</h1>

</p>
<p>
As this check is currently project specific, it is not documented for general use.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "CONCURRENCY2"> -->
<a name="CONCURRENCY2"></a><h1>CONCURRENCY2: Storing non-shared value ...</h1>


</p>
<p>
As this check is currently project specific, it is not documented for general use.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "CONCURRENCY3"> -->
<a name="CONCURRENCY3"></a><h1>CONCURRENCY3: Possible deadlock as follows</h1>


</p>
<p>
This complaint is issued in code assumed to be executed concurrently
by multiple threads.
It describes a possibility where several threads acquire a lock each,
and then they wait on each other to release a lock.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
Example:
</p>
<pre class="example">
typedef struct {
  void            *payload;
  pthread_mutex_t *m;
} shared_data;

shared_data x, y;

void copy(shared_data *a,
          shared_data *b)
{
  /* Since a and b could be shared by multiple threads, lock them both before accessing. */
  pthread_mutex_lock(a-&gt;m);
  pthread_mutex_lock(b-&gt;m);

  /* critical section containing real work of copying */

  pthread_mutex_unlock(b-&gt;m);
  pthread_mutex_unlock(a-&gt;m);
}


void foo()
{
  /* line 27: */ copy(&amp;x, &amp;y);

  /* line 29: */ copy(&amp;y, &amp;x);
}
</pre>
<p>

This will generate the following complaint
</p>
<pre class="example">
-- CONCURRENCY3     /*deadlock*/     &gt;&gt;&gt;CONCURRENCY3_foo_4d3bf348b3a5040
&quot;f.c&quot;, line 29: possible deadlock as follows

 Thread 1 acquires `(*(y.m))' because
   &quot;f.c&quot;, line 29: calling `copy'
    &quot;f.c&quot;, line 15: calling `pthread_mutex_lock'


 Thread 2 acquires `(*(x.m))' because
   &quot;f.c&quot;, line 27: calling `copy'
    &quot;f.c&quot;, line 15: calling `pthread_mutex_lock'


 Thread 1 blocks acquiring `(*(x.m))' because
   &quot;f.c&quot;, line 29: calling `copy'
    &quot;f.c&quot;, line 16: calling `pthread_mutex_lock'


 Thread 2 blocks acquiring `(*(y.m))' because
   &quot;f.c&quot;, line 27: calling `copy'
    &quot;f.c&quot;, line 16: calling `pthread_mutex_lock'
</pre>
<p>

</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "CONCURRENCY4"> -->
<a name="CONCURRENCY4"></a><h1>CONCURRENCY4: Acquiring non-recursive lock already held</h1>


</p>
<p>
This complaint is issued if a thread attempts to acquire twice the same non-recursive lock.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
Example:
</p>
<pre class="example">
typedef struct {
  void            *payload;
  pthread_mutex_t *m;
} shared_data;


void foo(shared_data *a)
{
  pthread_mutex_lock(a-&gt;m);
  pthread_mutex_lock(a-&gt;m);
}
</pre>
<p>

This will generate the following complaint
</p>
<pre class="example">
-- CONCURRENCY4     /*acquiring held lock*/     &gt;&gt;&gt;CONCURRENCY4_foo_3e800227b3a5040
&quot;g.c&quot;, line 13: Acquiring non-recursive lock already held

 Acquiring `(*(a-&gt;m))' because
   &quot;g.c&quot;, line 12: calling `pthread_mutex_lock'


 Acquiring `(*(a-&gt;m))' again because
   &quot;g.c&quot;, line 13: calling `pthread_mutex_lock'
</pre>
<p>

This complaint is applicable for non-recursive locks only.
However, it is not always obvious which locks are recursive.
Therefore the user can provide the assumption to be made in case of uncertainty
by using the parameter
<span class="var">beam::CONCURRENCY4::unknown_lock_is_recursive</span>.
If set to "yes" then CONCURRENCY4 will not be issued for any unknown lock.
It will be issued only if set to "no".
</p>
<p>
At this time, BEAM has a limitation in that it does not calculate which
locks are recursive and which are not.
Therefore all locks are considered "unknown".
The default setting of <span class="var">beam::CONCURRENCY4::unknown_lock_is_recursive</span>
is "yes" to avoid invalid complaints.
</p>
<p>
<br>
<br>
</p>
<p>
<!-- <snippet "CONCURRENCY5"> -->
<a name="CONCURRENCY5"></a><h1>CONCURRENCY5: Operation unprotected by lock</h1>


</p>
<p>
This complaint is issued for an operation (e.g., an assignment) on 
memory shared by several threads, where the operation is not protected by a lock.
"Shared memory" is memory reachable from external or static variables.
</p>
<p>
<!-- </snippet> -->
</p>
<p>
Example:
</p>
<pre class="example">
static void set_global()
{
  global_var = 0;
}

void external_function()
{
  set_global();
}
</pre>
<p>

This will generate the following complaint
</p>
<pre class="example">
-- CONCURRENCY5     /*no lock*/     &gt;&gt;&gt;CONCURRENCY5_external_function_a079397cb3a5040
&quot;f.C&quot;, line 16: Operation unprotected by lock

   &quot;f.C&quot;, line 16: calling `set_global'
    &quot;f.C&quot;, line 11: writing global_var = 0
</pre>
<p>

No complaint would be issued if <span class="function">set_global</span> were changed to
</p>
<pre class="example">
static void set_global()
{
  pthread_mutex_lock(&amp;global_mutex);  
  
  global_var = 0;
  
  pthread_mutex_unlock(&amp;global_mutex);
}
</pre>
<p>

Alternatively no complaint would be issued if <span class="function">external_function</span> were changed to
</p>
<pre class="example">
void external_function()
{
  pthread_mutex_lock(&amp;global_mutex); 
  
  set_global();
  
  pthread_mutex_unlock(&amp;global_mutex);
}
</pre>
<p>

At this time this complaint applies only to C/C++, not to Java.
It is not issued for static functions, because
all their call sites are visible to BEAM; that enables us to
issue the complaint only if a static function with unprotected operation
is called, and the call is not protected by any lock either.
The complaint is issued only for externally visible functions.
</p>
<p>
The value of enabling_policy is a  <a href="parms.html#patterns">pattern</a>
with the following meaning.
</p>
<p>
<table>
<tr><th align=left>Parameter<th align=left>Value<th align=left>Effect
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;assign&quot;</span>
 <td>Complaint will be issued for assignments to shared memory
     unprotected by a lock.
</tr>
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;fetch&quot;</span>
 <td>Complaint will be issued for fetches of shared memory
     unprotected by a lock.
</tr>
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;initialize&quot;</span>
 <td>Complaint will be issued for initialization of shared memory
     unprotected by a lock, provided the initialization does not
     happen at load time.
     This is an issue for C++ static variables declared in function 
     scope, and only if the initializer must be evaluated the first time
     the function is called. No lock is needed if the initializer
     is a constant.
     Please be aware that several C++ compilers automatically insert
     locking around such initializers, although it is not a language
     requirement. Therefore turn on this BEAM
     option only if you do not want to rely on such compiler features.
</tr>
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;unknown_assign&quot;</span>
 <td>Complaint will be issued for a call to a function whose body
     is not available to BEAM, and whose <a href="attributes.html">attributes</a>
     (or lack of) allow assignments to shared memory unprotected by a lock.
</tr>
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;unknown_fetch&quot;</span>
 <td>Complaint will be issued for a call to a function whose body
     is not available to BEAM, and whose <a href="attributes.html">attributes</a>
     (or lack of) allow fetches of shared memory unprotected by a lock.
</tr>
<tr>
 <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
 <td><span class="val">&quot;always&quot;</span>
 <td>Complaint will be issued for any of the above operations on shared memory
     unprotected by a lock.
</tr>
<tr>
  <td><span class="var">beam::CONCURRENCY5::enabling_policy</span>
  <td><span class="val">&quot;&quot;</span>
  <td>Complaint will never be issued.
</tr>
</table>
</p>

</td>

</table>

</div>

</body>
</html>
