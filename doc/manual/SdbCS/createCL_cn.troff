.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "createCL" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH 名称
.PP
createCL \- 创建集合
.SH 语法
.PP
\f[B]db.collectionspace.createCL(<name>, [options])\f[]
.SH 类别
.PP
SdbCS
.SH 描述
.PP
该函数用于在指定集合空间下创建集合（Collection）。集合是数据库中存放文档记录的逻辑对象，任何一条文档记录必须属于且仅属于一个集合。
.SH 参数
.IP \[bu] 2
name（ \f[I]string，必填\f[] ）
.RS 2
.PP
集合名
.IP \[bu] 2
在同一个集合空间中，集合名必须唯一。
.IP \[bu] 2
有关集合与集合命名的限制可参考限制。
.RE
.IP \[bu] 2
options（ \f[I]object，选填\f[] ）
.RS 2
.PP
通过参数 options 可以设置集合的属性：
.IP \[bu] 2
ShardingKey（ \f[I]object\f[] ）：分区键，取值为 1 或 \-1，表示正向或逆向排序
.RS 2
.PP
格式：\f[C]ShardingKey: {<字段1>: <1|\-1>, [<字段2>: <1|\-1>, ...]}\f[]
.RE
.IP \[bu] 2
ShardingType（ \f[I]string\f[] ）：分区方式，默认值为 "hash"
.RS 2
.PP
取值如下：
.IP \[bu] 2
"hash"：散列分区
.IP \[bu] 2
"range"：范围分区
.PP
格式：\f[C]ShardingType: "range"\f[]
.RE
.IP \[bu] 2
Partition（ \f[I]number\f[] ）：分区数，默认值为 4096
.RS 2
.IP \[bu] 2
该参数取值必须是 2 的幂，范围在[2^3，2^20]。
.IP \[bu] 2
参数 ShardingType 的取值为"hash"时，该参数才能生效。
.PP
格式：\f[C]Partition: 4096\f[]
.RE
.IP \[bu] 2
ReplSize（ \f[I]number\f[] ）：写操作需同步的副本数，默认值为
1，表示写操作只需写入主节点
.RS 2
.PP
取值如下：
.IP \[bu] 2
\-1：写请求需同步到该复制组若干活跃的节点之后，数据库写操作才返回应答给客户端
.IP \[bu] 2
0：写请求需同步到该复制组的所有节点之后，数据库写操作才返回应答给客户端
.IP \[bu] 2
1~7：写请求需同步到该复制组指定数量个节点之后，数据库写操作才返回应答给客户端
.PP
格式：\f[C]ReplSize: 0\f[]
.RE
.IP \[bu] 2
ConsistencyStrategy（ \f[I]number\f[] ）：同步一致性策略
.RS 2
.PP
该参数用于指定数据同步优先选择的节点，默认值为 3。
.PP
取值如下：
.IP \[bu] 2
1：节点优先策略
.IP \[bu] 2
2：位置多数派优先策略
.IP \[bu] 2
3：主位置多数派优先策略
.PP
格式：\f[C]ConsistencyStrategy: 3\f[]
.RE
.IP \[bu] 2
Compressed（ \f[I]boolean\f[] ）：是否开启数据压缩功能，默认值为
true，表示开启数据压缩功能
.RS 2
.PP
格式：\f[C]Compressed: false\f[]
.RE
.IP \[bu] 2
CompressionType（ \f[I]string\f[] ）：压缩算法类型，默认值为 "lzw"
.RS 2
.PP
取值如下：
.IP \[bu] 2
"snappy"：snappy 算法压缩
.IP \[bu] 2
"lzw"：lzw 算法压缩
.PP
格式：\f[C]CompressionType: "snappy"\f[]
.RS
.PP
\f[B]Note:\f[]
.PP
snappy 压缩和 lzw 压缩的使用场景可参考数据压缩。
.RE
.RE
.IP \[bu] 2
AutoSplit（ \f[I]boolean\f[] ）：是否开启自动切分功能，默认值为
false，不开启自动切分
.RS 2
.IP \[bu] 2
该参数不能与参数 Group 同时使用。
.IP \[bu] 2
参数 ShardingType 的取值为"hash"时，该参数才能生效。
.PP
格式：\f[C]AutoSplit: true\f[]
.RS
.PP
\f[B]Note:\f[]
.PP
创建域和集合时均可指定参数 AutoSplit。如果显式指定集合的
AutoSplit，系统将优先按集合指定的值决定是否开启自动切分。
.RE
.RE
.IP \[bu] 2
Group（ \f[I]string\f[] ）：所属复制组
.RS 2
.IP \[bu] 2
该参数指定的值必须是集合所属域中包含的复制组。
.IP \[bu] 2
如果未指定该参数的值，集合将创建在集合所属域的任意一个复制组中。
.PP
格式：\f[C]Group: "group1"\f[]
.RE
.IP \[bu] 2
AutoIndexId（ \f[I]boolean\f[] ）：是否根据字段 _id
自动创建名为"$id"的唯一索引，默认值为 true，表示自动创建
.RS 2
.PP
格式：\f[C]AutoIndexId: false\f[]
.RE
.IP \[bu] 2
EnsureShardingIndex（ \f[I]boolean\f[] ）：是否根据参数 ShardingKey
指定的字段自动创建名为 "$shard" 的索引，默认值为 true，自动创建
.RS 2
.PP
格式：\f[C]EnsureShardingIndex: false\f[]
.RE
.IP \[bu] 2
StrictDataMode（ \f[I]boolean\f[] ）：是否开启严格数据类型模式，默认为
false，不开启
.RS 2
.PP
开启严格模式后，如果数据类型为数值，在运算过程中出现溢出则会报错；如果数据类型非数值，则不进行任何操作。
.PP
格式：\f[C]StrictDataMode: true\f[]
.RE
.IP \[bu] 2
AutoIncrement（ \f[I]object\f[] ）：自增字段，功能介绍可参考自增字段
.RS 2
.PP
格式：\f[C]AutoIncrement: {Field: <字段名>, ...}\f[] 或
\f[C]AutoIncrement: [{Field: <字段名1>, ...}, {Field: <字段名2>, ...}, ...]\f[]
.RE
.IP \[bu] 2
LobShardingKeyFormat（ \f[I]string\f[] ）：指定大对象 ID
转换为分区键键值的转换格式
.RS 2
.PP
目前仅支持对大对象 ID 中的时间属性进行转换，格式如下：
.IP \[bu] 2
"YYYYMMDD"：转换为年月日的字符串形式，如 "20190701"
.IP \[bu] 2
"YYYYMM"：转换为年月的字符串形式，如 "201907"
.IP \[bu] 2
"YYYY"：转换为年的字符串形式，如 "2019"
.PP
该参数仅在主集合中使用。当指定该参数时，必须保证参数 ShardingKey
指定的切分字段只有一个。
.PP
格式：\f[C]LobShardingKeyFormat: "2021"\f[]
.RE
.IP \[bu] 2
IsMainCL（ \f[I]boolean\f[] ）：是否为主集合，默认值为 false，不设置为主集合
.RS 2
.PP
当指定集合为主集合时，子集合中的参数 ReplSize 和 AutoIncrement
会沿用主集合中对应参数的值，其他参数沿用自身参数的值。
.PP
格式：\f[C]IsMainCL: true\f[]
.RE
.IP \[bu] 2
DataSource（ \f[I]string\f[] ）：所使用的数据源名称
.RS 2
.PP
格式：\f[C]DataSource: "ds1"\f[]
.RE
.IP \[bu] 2
Mapping（ \f[I]string\f[] ）：所映射的集合名称
.RS 2
.PP
格式：\f[C]Mapping: "employee"\f[]
.RS
.PP
\f[B]Note:\f[]
.PP
参数 DataSource 和 Mapping 的具体使用场景可参考数据源。
.RE
.RE
.RE
.SH 返回值
.PP
函数执行成功时，将返回一个 SdbCollection 类型的对象。
.PP
函数执行失败时，将抛异常并输出错误信息。
.SH 错误
.PP
\f[C]createCL()\f[] 函数常见异常如下：
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
错误码
T}@T{
错误类型
T}@T{
可能发生的原因
T}@T{
解决办法
T}
_
T{
1
T}@T{
\-2
T}@T{
SDB_OOM
T}@T{
无可用内存
T}@T{
检查物理内存及
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
虚拟内存的情况
T}
T{
2
T}@T{
\-6
T}@T{
SDB_INVALIDARG
T}@T{
参数错误
T}@T{
查看参数是否填
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
写正确
T}
T{
3
T}@T{
\-22
T}@T{
SDB_DMS_EXIST
T}@T{
集合已存在
T}@T{
检查集合是否存
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
在
T}
T{
4
T}@T{
\-34
T}@T{
SDB_DMS_CS_NOTEXIST
T}@T{
集合空间不存在
T}@T{
检查集合空间是
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
否存在
T}
T{
5
T}@T{
\-318
T}@T{
SDB_VALUE_OVERFLOW
T}@T{
数值运算出现溢
T}@T{
检查运算过程是
T}
T{
T}@T{
T}@T{
T}@T{
出
T}@T{
否存在溢出情况
T}
.TE
.PP
当异常抛出时，可以通过 getLastErrMsg() 获取错误信息或通过 getLastError()
获取错误码。更多错误处理可以参考常见错误处理指南。
.SH 版本
.PP
v1.0 及以上版本
.SH 示例
.IP \[bu] 2
在集合空间 sample 下创建集合 employee，不指定分区键
.RS 2
.IP
.nf
\f[C]
> db.sample.createCL("employee")
\f[]
.fi
.RE
.IP \[bu] 2
在集合空间 sample 下创建集合 employee，指定分区键为字段 age、分区数为 4096 进行
hash 切分；指定参数 ReplSize 为 1，当发出写请求时，只需写入主节点即可返回
.RS 2
.IP
.nf
\f[C]
> db.sample.createCL("employee", {ShardingKey: {age: 1}, ShardingType: "hash", Partition: 4096, ReplSize: 1})
\f[]
.fi
.RE
.IP \[bu] 2
在集合空间 sample 下创建集合 employee，指定开启严格数据类型模式
.RS 2
.IP
.nf
\f[C]
> db.sample.createCL("employee", {StrictDataMode: true})
\f[]
.fi
.RE
.IP \[bu] 2
在主集合下使用大对象
.RS 2
.PP
创建支持大对象的主集合 sample.maincl，将子集合 sample.subcl
挂载到该主集合上，并指定分区范围为 [20190701, 20190801)
.IP
.nf
\f[C]
> db.sample.createCL("maincl", {LobShardingKeyFormat: "YYYYMMDD", ShardingKey: {date: 1}, IsMainCL: true, ShardingType: "range"})
> db.sample.createCL("subcl")
> db.sample.maincl.attachCL("sample.subcl", {LowBound: {date: "20190701"}, UpBound: {date: "20190801"}})
\f[]
.fi
.PP
创建大对象 ID 并指定时间属性
.IP
.nf
\f[C]
> db.sample.maincl.createLobID("2019\-07\-23\-18.04.07")
00005d36db97360002de8081
\f[]
.fi
.PP
指定大对象 ID，将文件 \f[C]/opt/data/test.dat\f[] 以大对象形式插入集合
sample.maincl 中
.IP
.nf
\f[C]
> db.sample.maincl.putLob(\[aq]/opt/data/test.dat\[aq], \[aq]00005d36db97360002de8081\[aq])
00005d36db97360002de8081
\f[]
.fi
.PP
不指定大对象 ID，直接将文件 \f[C]/opt/data/test.dat\f[] 以大对象形式插入集合
sample.maincl 中，插入成功后自动生成大对象 ID，其时间属性为当前时间
.IP
.nf
\f[C]
> db.sample.maincl.putLob(\[aq]/opt/data/test.dat\[aq])
00005d36dbee370002de8080
\f[]
.fi
.RE
