.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "importOnce" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH NAME
.PP
importOnce \- Global only import and eval js file once.
.SH SYNOPSIS
.PP
\f[B]importOnce(<filename>)\f[]
.SH CATEGORY
.PP
Global
.SH DESCRIPTION
.PP
Meets the demand to import existing js files.
.PP
\f[B]Note:\f[]
.IP "1." 3
In a js script, if the imported file and the script have multiple definitions
for the same function, then if you first import the file and then define the
same function in the script,the actual function definition will be the function
defined in the import file.The reason for this phenomenon is that js engine will
read the function definition of the js script before running,and the function
definition in the imported file is read when the import method is run, this lead
to the effective function definition is the function definition in the imported
file.By placing the function definition in the script into another file and then
importing it,you can circumvent this problem.
.SH PARAMETERS
.IP \[bu] 2
\f[C]filename\f[] ( \f[I]String\f[]， \f[I]Required\f[] )
.PP
The relative path or the full path of js file。
.SH RETURN VALUE
.PP
On success, importOnce() returns the value of the imported file.
.PP
On error, exception will be thrown.
.SH ERRORS
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Error code
T}@T{
Error type
T}@T{
Description
T}@T{
solution
T}
_
T{
1
T}@T{
\-152
T}@T{
SDB_SPT_EVAL_FAIL
T}@T{
Evalution failed with
T}@T{
Debug by error line
T}
T{
T}@T{
T}@T{
T}@T{
error
T}@T{
number
T}
.TE
.PP
When exception happen, use getLastError() to get the error code and use
getLastErrMsg() to get error message.
For more detial, please reference to Troubleshooting.
.SH HISTORY
.PP
Since v2.9
.SH EXAMPLES
.IP "1." 3
Import and eval helloWorld.js repeatly,only import and eval for the first time.
.RS 4
.IP "1)" 3
The content of helloWorld.js as below:
.IP
.nf
\f[C]
function sayHello()
{
    println( "hello world" ) ;
}
println( "import helloWorld.js" ) ;
\f[]
.fi
.IP "2)" 3
Import and eval helloWorld.js repeatly,only import and eval for the first time.
.IP
.nf
\f[C]
> importOnce( \[aq]helloWorld.js\[aq] )
import helloWorld.js
Takes 0.000849s.
> importOnce( \[aq]helloWorld.js\[aq] )
Takes 0.000354s.
> sayHello()
hello world
Takes 0.000436s.
\f[]
.fi
.RE
.IP "2." 3
The problem of repeated function definition and the way to avoid problem
.RS 4
.IP \[bu] 2
Problem description and example
.RS 2
.IP "1)" 3
The content of funcDef.js as below:
.IP
.nf
\f[C]
function test()
{
    println( "defined in funcDef.js" ) ;
}  
\f[]
.fi
.IP "2)" 3
The content of test.js as below：
.IP
.nf
\f[C]
importOnce( \[aq]./funcDef.js\[aq] ) ;
function test()
{
    println( \[aq]defined in test.js\[aq] ) ;
}
test() ;
\f[]
.fi
.IP "3)" 3
Use sdb to run test.js
.IP
.nf
\f[C]
$ ./sdb \-f test.js 
defined in funcDef.js
\f[]
.fi
.PP
The result means the effective function definition is the function definition in
the funcDef.js.
.RE
.IP \[bu] 2
The way to avoid problem
.RS 2
.PP
By placing the function definition in the script into another file and then
importing it,you can circumvent this problem.
.IP "1)" 3
Create a file named userDef.js,the content as below：
.IP
.nf
\f[C]
function test()
{
    println( \[aq]defined in userDef.js\[aq] ) ;
}
\f[]
.fi
.IP "2)" 3
The content of test.js is changed as below：
.IP
.nf
\f[C]
importOnce( \[aq]./funcDef.js\[aq] ) ;
importOnce( \[aq]./userDef.js\[aq] ) ;
test() ;
\f[]
.fi
.IP "3)" 3
Use sdb to run test.js
.IP
.nf
\f[C]
$ ./sdb \-f test.js
defined in userDef.js
\f[]
.fi
.PP
The result means the effective function definition is the function definition in
the userDef.js.
.RE
.RE
