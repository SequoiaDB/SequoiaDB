.\" Automatically generated by Pandoc 1.18
.\"
.TH "explain" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH NAME
.PP
explain \- Return the access plan of the current query.
.SH SYNOPSIS
.PP
\f[B]\f[I]db.collectionspace.collection.find([cond],[sel]).explain([options])\f[]\f[]
\f[B]\f[I]db.collectionspace.collection.find([cond],[sel])[.hint([hint])][.skip([skipNum])][.limit([retNum])][.sort([sort])].explain([options])\f[]\f[]
.SH CATEGORY
.PP
Collection
.SH "DESCRIPTION"

.sp 2
Return the access plan of the current query.
.sp 2
\fBoption (Json Object)\fR
.br
       Access plan execution plan, now we have: Run field:
       whether execute the Access Plan. True is to execute, get
       data and time information; False represents only get the
       Access Plan's info, but not executing it.
.sp 2
       \fBName (string)\fR
.br
              Collection Name.
.sp 2
       \fBScanType (string)\fR
.br
              Scanning Type: TableScan: "tbscan";
              IndexScan:"ixscan"
.sp 2
       \fBIndexName (string)\fR
.br
              Index name.
.sp 2
       \fBUseExtSort (bool)\fR
.br
              Whether use external sort or not.
.sp 2
       \fBNodeName (string)\fR
.br
              Node Name.
.sp 2
       \fBReturnNum (int64)\fR
.br
              Number of returned records.
.sp 2
       \fBElapsedTime (float64)\fR
.br
              Elapsed Time(seconds).
.sp 2
       \fBIndexRead (int64)\fR
.br
              Number of Index read.
.sp 2
       \fBDataRead (int64)\fR
.br
              Number of data read.
.sp 2
       \fBUserCPU (float64)\fR
.br
              Time used by cpu in user mode(seconds).
.sp 2
       \fBSysCPU (float64)\fR
.br
              Time used by cpu in kernel mode(seconds).
.sp 2
       \fBSubCollections (Json Array)\fR
.br
              The access plan of each sub-collections of the
              vertical-partitioning collection.
.sp 2
\fBNote: \fR
.sp 2
   *  If the collection is splitted into different replica
   groups, each replica group will return its own access plan
   correspondingly.
.SH "Examples"

.sp 2
Suppose foo.bar is a horizontal-partitioning collection splitted
in three replica groups.
.sp 1
db.foo.bar.find().sort({b:1}).explain({Run:true})
.sp 1
Return:
.sp 1
{
.br
  "Name": "foo.bar",
.br
  "ScanType": "tbscan",
.br
  "IndexName": "",
.br
  "UseExtSort": true,
.br
  "NodeName": "vmsvr2-cent-x64:40020",
.br
  "ReturnNum": 38,
.br
  "ElapsedTime": 0.000477,
.br
  "IndexRead": 0,
.br
  "DataRead": 38,
.br
  "UserCPU": 0,
.br
  "SysCPU": 0
.br
}
.br
{
.br
  "Name": "foo.bar",
.br
  "ScanType": "tbscan",
.br
  "IndexName": "",
.br
  "UseExtSort": true,
.br
  "NodeName": "vmsvr2-cent-x64:40000",
.br
  "ReturnNum": 34,
.br
  "ElapsedTime": 0.000415,
.br
  "IndexRead": 0,
.br
  "DataRead": 34,
.br
  "UserCPU": 0,
.br
  "SysCPU": 0
.br
}
.br
{
.br
  "Name": "foo.bar",
.br
  "ScanType": "tbscan",
.br
  "IndexName": "",
.br
  "UseExtSort": true,
.br
  "NodeName": "vmsvr2-cent-x64:40010",
.br
  "ReturnNum": 28,
.br
  "ElapsedTime": 0.000517,
.br
  "IndexRead": 0,
.br
  "DataRead": 28,
.br
  "UserCPU": 0,
.br
  "SysCPU": 0
.br
}
