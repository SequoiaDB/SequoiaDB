.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "upsert" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH NAME
.PP
upsert \- update collection records
.SH SYNOPSIS
.PP
\f[B]db.collectionspace.collection.upsert(<rule>, [cond], [hint], [setOnInsert],
[options])\f[]
.SH CATEGORY
.PP
SdbCollection
.SH DESCRIPTION
.PP
This function is used to update collection records.
The upsert method and the update method both update records.
The difference is that when the cond parameter is used to match no records in
the collection, update does nothing, while the upsert method does an insert
operation.
.SH PARAMETERS
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}@T{
Required or not
T}
_
T{
1
T}@T{
rule
T}@T{
object
T}@T{
Update rules.
The
T}@T{
required
T}
T{
T}@T{
T}@T{
T}@T{
record is updated
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
according to the
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
content of the rule.
T}@T{
T}
T{
2
T}@T{
cond
T}@T{
object
T}@T{
Selection condition.
T}@T{
required
T}
T{
T}@T{
T}@T{
T}@T{
When it is empty,
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
update all records.
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
When it is not empty,
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
update the records that
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
meet the conditions.
T}@T{
T}
T{
3
T}@T{
hint
T}@T{
object
T}@T{
Specify an access plan.
T}@T{
not
T}
T{
4
T}@T{
options
T}@T{
object
T}@T{
Options.
For more
T}@T{
not
T}
T{
T}@T{
T}@T{
T}@T{
details, refer to the
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
description of options.
T}@T{
T}
.TE
.PP
options:
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}@T{
Default
T}
_
T{
1
T}@T{
KeepShardingKey
T}@T{
boolean
T}@T{
false: do not keep the
T}@T{
false
T}
T{
T}@T{
T}@T{
T}@T{
partition key field in
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
the update rule, and
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
only update the non\-
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
partition key field.true: keep the
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
partition key field in
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
the update rule
T}@T{
T}
T{
2
T}@T{
JustOne
T}@T{
boolean
T}@T{
true: Only update one
T}@T{
false
T}
T{
T}@T{
T}@T{
T}@T{
eligible record
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
false: Update all
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
eligible records
T}@T{
T}
.TE
.RS
.PP
\f[B]Note:\f[]
.IP \[bu] 2
The usage of the parameter "hint" are same as the way of find().
.IP \[bu] 2
When the "cond" parameter does not match a record in the collection, upsert will
generate a record and insert it into the collection.The rules for generating
records are: First, take out the key\-value pairs corresponding to the $et and
$all operators from the "cond" parameter, and generate an empty record if not.
Then use the rule to update it, and finally add the key\-value pair in
"setOnInsert".
.IP \[bu] 2
The partition key updates are not supported on partition collection currently.
If "KeepShardingKey" is true and there is a partition key field in the update
rule, an error \-178 will be reported.
.IP \[bu] 2
When "JustOne" is true, it can only be executed on a single partition and a
single subtable.
.RE
.SH RETURN VALUE
.PP
When the function executes successfully, it will return an object of type
BSONObj.
Users can get the number of successfully updated records through this object.
Field descriptions are as follows:
.PP
.TS
tab(@);
l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}
_
T{
1
T}@T{
UpdatedNum
T}@T{
int64
T}@T{
The number of records
T}
T{
T}@T{
T}@T{
T}@T{
successfully updated,
T}
T{
T}@T{
T}@T{
T}@T{
including records that
T}
T{
T}@T{
T}@T{
T}@T{
match but have no data
T}
T{
T}@T{
T}@T{
T}@T{
changes.
T}
T{
2
T}@T{
ModifiedNum
T}@T{
int64
T}@T{
The number of records
T}
T{
T}@T{
T}@T{
T}@T{
successfully updated
T}
T{
T}@T{
T}@T{
T}@T{
with data changes.
T}
T{
3
T}@T{
InsertedNum
T}@T{
int64
T}@T{
Number of records
T}
T{
T}@T{
T}@T{
T}@T{
successfully inserted.
T}
.TE
.PP
When the function fails, an exception will be thrown and an error message will
be printed.
.SH ERRORS
.PP
The common exceptions of \f[C]upsert()\f[] function are as follows:
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Error Code
T}@T{
Error Type
T}@T{
Description
T}@T{
Solution
T}
_
T{
1
T}@T{
\-178
T}@T{
SDB_UPDATE_SHARD_KEY
T}@T{
Update partition key is
T}@T{
The value of "
T}
T{
T}@T{
T}@T{
T}@T{
not supported on
T}@T{
KeepShardingKey" is
T}
T{
T}@T{
T}@T{
T}@T{
partition collection.
T}@T{
false, and the
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
partition key is not
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
updated.
T}
T{
2
T}@T{
\-347
T}@T{
SDB_COORD_UPDATE_MULTI_
T}@T{
When the parameter "
T}@T{
Modify the matching
T}
T{
T}@T{
T}@T{
NODES
T}@T{
JustOne" is true,
T}@T{
conditions or do not
T}
T{
T}@T{
T}@T{
T}@T{
update records across
T}@T{
use the parameter "
T}
T{
T}@T{
T}@T{
T}@T{
multiple partitions or
T}@T{
JustOne".
T}
T{
T}@T{
T}@T{
T}@T{
subtables.
T}@T{
T}
.TE
.PP
When the exception happens, use getLastErrMsg() to get the error message or use
getLastError() to get the error code.
For more details, refer to Troubleshooting.
.SH VERSION
.PP
v2.0 and above
.SH EXAMPLES
.PP
Suppose there are two records in the collection "sample.employee".
.IP
.nf
\f[C]
{
  "_id": {
    "$oid": "516a76a1c9565daf06030000"
  },
  "age": 10,
  "name": "Tom"
}
{
  "_id": {
    "$oid": "516a76a1c9565daf06050000"
  },
  "a": 10,
  "age": 21
}
\f[]
.fi
.IP \[bu] 2
Update all records in the collection according to the specified update rule,
which is set the "rule" parameter, not the "cond" and "hint" parameters.
The following operation is equivalent to using the update method to update all
records in the collection "sample.employee", using $inc to increase the value of
the age field of the record by 1, and change the value of the "name" field to
"Mike".
For the record that does not have the "name" field , $set operator will insert
the "name" field and its set value into the record, user can use the find method
to view the update result.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}, $set: {name: "Mike"}})
{
  "UpdatedNum": 2,
  "ModifiedNum": 2,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06030000"
     },
     "age": 11,
     "name": "Mike"
}
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 22,
     "name":"Mike"
}
Return 2 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
Select the records that meet the matching conditions, and update these records
according to the update rules, which is set the "rule" and "cond" parameters.
The following operation uses $exists to match records with the "type" field, and
uses $inc to increase the "age" field value of these records by 3.
In the two records given above, there is no "type" field.
At this time, the upsert operation will insert a new record.
The new record only has the "_id" field and the "age" field name.
The "_id" field value will be automatically generated, and the "age" field value
Is 3.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 3}}, {type: {$exists: 1}})
{
  "UpdatedNum": 0,
  "ModifiedNum": 0,
  "InsertedNum": 1
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06030000"
     },
     "age": 11,
     "name": "Mike"
}
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 22,
     "name":"Mike"
}
{
     "_id": {
     "$oid": "516cfc334630a7f338c169b0"
     },
     "age": 3
}
Return 3 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
Update records by access plan.
Assuming that the specified index name "testIndex" exists in the collection,
this operation is equivalent to using the update method, using the index named
"testIndex" to access the records whose "age" field value is greater than 20 in
the collection "sample.employee", and adding 1 to the "age" field name of these
records.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}}, {age: {$gt: 20}}, {"": "testIndex"})
{
  "UpdatedNum": 1,
  "ModifiedNum": 1,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 23,
     "name":"Mike"
}
Return 1 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
Use setOnInsert to update the record.
Since the records with the "age" field value greater than 30 in the collection
employee are empty, upsert appends the field {"name":"Mike"} to the inserted
record when doing the insert operation.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}}, {age: {$gt: 30}}, {}, {"name": "Mike"})
{
  "UpdatedNum": 0,
  "ModifiedNum": 0,
  "InsertedNum": 1
}
>
> db.sample.employee.find({"age": 1, "name": "Mike"})
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "age":1,
     "name":"Mike"
} 
Return 1 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
The partition collection "sample.employee" and the partition key is {a: 1}.
It contains the following records.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.find()
{
  "_id": {
    "$oid": "5c6f660ce700db6048677154"
  },
  "a": 1,
  "b": 1
}
Return 1 row(s).
\f[]
.fi
.PP
Specify the "KeepShardingKey" parameter: Do not keep the partition key field in
the update rule.
Only the non\-partition key "b" field is updated, and the value of the partition
key "a" field is not updated.
.IP
.nf
\f[C]
> db.sample.employee.upsert({$set: {a: 9, b: 9}}, {}, {}, {}, {KeepShardingKey: false})
{
  "UpdatedNum": 1,
  "ModifiedNum": 1,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
  "_id": {
    "$oid": "5c6f660ce700db6048677154"
  },
  "a": 1,
  "b": 9
}
Return 1 row(s).
\f[]
.fi
.PP
Specify the "KeepShardingKey" parameter: Keep the partition key field in the
update rule.
Since updating the partition key is currently not supported, an error will be
reported.
.IP
.nf
\f[C]
> db.sample.employee.upsert({$set: {a: 9}}, {}, {}, {}, {KeepShardingKey: true})
(nofile):0 uncaught exception: \-178
Sharding key cannot be updated
\f[]
.fi
.RE
