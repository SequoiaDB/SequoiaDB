.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "insert" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH NAME
.PP
insert \- insert record into the current collection
.SH SYNOPSIS
.PP
\f[B]db.collectionspace.collection.insert(<doc|docs>, [flag])\f[]
.PP
\f[B]db.collectionspace.collection.insert(<doc|docs>, [options])\f[]
.SH CATEGORY
.PP
SdbCollection
.SH DESCRIPTION
.PP
This function is used to insert single or multiple records into the current
collection.
.SH PARAMETERS
.IP \[bu] 2
doc|docs ( \f[I]object/array, required\f[] )
.RS 2
.PP
Single or multiple records
.RE
.IP \[bu] 2
flag ( \f[I]number, optional\f[] )
.RS 2
.PP
Flag bit, used to control the behavior and result of insert operation.
If this parameter is not specified, the insert operation will not return the
content of the field "_id" by default, and an error will be reported when an
index key conflict occurs.
.PP
the value is as follows:
.IP \[bu] 2
SDB_INSERT_RETURN_ID: After successful insertion, return the content of the
field "_id" in the record.
.IP \[bu] 2
SDB_INSERT_CONTONDUP: When an index key conflict occurs, skip this record and
continue to insert other records.
.IP \[bu] 2
SDB_INSERT_REPLACEONDUP: When an index key conflict occurs, the new record will
overwrite the original record and continue to insert other records.
.IP \[bu] 2
SDB_INSERT_CONTONDUP_ID: When $id index key conflict occurs, skip this record
and continue to insert other records.
.IP \[bu] 2
SDB_INSERT_REPLACEONDUP_ID: When $id index key conflict occurs, the new record
will overwrite the original record and continue to insert other records.
.RS
.PP
\f[B]Noteï¼š\f[]
.IP \[bu] 2
"SDB_INSERT_RETURN_ID" supports specifying with other flags at the same time,
multiple values are separated by "|".
.IP \[bu] 2
For "SDB_INSERT_CONTONDUP", "SDB_INSERT_REPLACEONDUP", "SDB_INSERT_CONTONDUP_ID"
and "SDB_INSERT_REPLACEONDUP_ID" do not support specifying multiple.
.RE
.RE
.IP \[bu] 2
options ( \f[I]object\f[] )
.RS 2
.PP
The behavior and result of the insert operation can be controlled through the
parameter "options":
.IP \[bu] 2
ReturnOID ( \f[I]boolean\f[] ): Consistent with the behavior of
"SDB_INSERT_RETURN_ID" in the parameter "flag".
.RS 2
.PP
Format: \f[C]ReturnOID: true\f[]
.RE
.IP \[bu] 2
ContOnDup ( \f[I]boolean\f[] ): Consistent with the behavior of
"SDB_INSERT_CONTONDUP" in the parameter "flag".
.RS 2
.PP
Format: \f[C]ContOnDup: true\f[]
.RE
.IP \[bu] 2
ReplaceOnDup ( \f[I]boolean\f[] ): Consistent with the behavior of
"SDB_INSERT_REPLACEONDUP" in the parameter "flag".
.RS 2
.PP
Format: \f[C]ReplaceOnDup: true\f[]
.RE
.IP \[bu] 2
ContOnDupID ( \f[I]boolean\f[] ): Consistent with the behavior of
"SDB_INSERT_CONTONDUP_ID" in the parameter "flag".
.RS 2
.PP
Format: \f[C]ContOnDupID: true\f[]
.RE
.IP \[bu] 2
ReplaceOnDupID ( \f[I]boolean\f[] ): Consistent with the behavior of
"SDB_INSERT_REPLACEONDUP_ID" in the parameter "flag".
.RS 2
.PP
Format: \f[C]ReplaceOnDupID: true\f[]
.RE
.RS
.PP
\f[B]Note:\f[]
.IP \[bu] 2
If the parameter "options" is not specified, the insert operation will not
return the content of the field "_id" by default, and an error will be reported
when an index key conflict occurs.
.IP \[bu] 2
For the parameters "ContOnDup", "ReplaceOnDup", "ContOnDupID" and
"ReplaceOnDupID" do not support specifying multiple as true at the same time.
.RE
.RE
.SH RETURN VALUE
.PP
When the function executes successfully, it will return an object of type
BSONObj.
Users can get information about the number of successfully inserted records
through this object, field descriptions are as follows:
.PP
.TS
tab(@);
l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}
_
T{
1
T}@T{
InsertedNum
T}@T{
int64
T}@T{
The number of records
T}
T{
T}@T{
T}@T{
T}@T{
successfully inserted.(
T}
T{
T}@T{
T}@T{
T}@T{
not including records
T}
T{
T}@T{
T}@T{
T}@T{
that were overwritten)
T}
T{
2
T}@T{
DuplicatedNum
T}@T{
int64
T}@T{
The number of records
T}
T{
T}@T{
T}@T{
T}@T{
covered due to index
T}
T{
T}@T{
T}@T{
T}@T{
key conflicts.
T}
T{
3
T}@T{
LastGenerateID
T}@T{
int64
T}@T{
The value of the auto\-
T}
T{
T}@T{
T}@T{
T}@T{
increment field (only
T}
T{
T}@T{
T}@T{
T}@T{
displayed when the
T}
T{
T}@T{
T}@T{
T}@T{
collection contains
T}
T{
T}@T{
T}@T{
T}@T{
auto\-increment), the
T}
T{
T}@T{
T}@T{
T}@T{
return situation is as
T}
T{
T}@T{
T}@T{
T}@T{
follows: \- When
T}
T{
T}@T{
T}@T{
T}@T{
inserting a single
T}
T{
T}@T{
T}@T{
T}@T{
record, return the auto
T}
T{
T}@T{
T}@T{
T}@T{
\-incremented field
T}
T{
T}@T{
T}@T{
T}@T{
value corresponding to
T}
T{
T}@T{
T}@T{
T}@T{
the record.\- When
T}
T{
T}@T{
T}@T{
T}@T{
inserting multiple
T}
T{
T}@T{
T}@T{
T}@T{
records, only return
T}
T{
T}@T{
T}@T{
T}@T{
the increment field
T}
T{
T}@T{
T}@T{
T}@T{
value corresponding to
T}
T{
T}@T{
T}@T{
T}@T{
the first record.\-
T}
T{
T}@T{
T}@T{
T}@T{
When there are multiple
T}
T{
T}@T{
T}@T{
T}@T{
auto\-increment fields,
T}
T{
T}@T{
T}@T{
T}@T{
insert a single record
T}
T{
T}@T{
T}@T{
T}@T{
and only return the
T}
T{
T}@T{
T}@T{
T}@T{
maximum value of all
T}
T{
T}@T{
T}@T{
T}@T{
auto\-increment fields.
T}
T{
T}@T{
T}@T{
T}@T{
 \- When there are
T}
T{
T}@T{
T}@T{
T}@T{
multiple auto\-increment
T}
T{
T}@T{
T}@T{
T}@T{
fields, insert
T}
T{
T}@T{
T}@T{
T}@T{
multiple records and
T}
T{
T}@T{
T}@T{
T}@T{
only return the largest
T}
T{
T}@T{
T}@T{
T}@T{
auto\-increment field
T}
T{
T}@T{
T}@T{
T}@T{
value corresponding to
T}
T{
T}@T{
T}@T{
T}@T{
the first record.
T}
T{
4
T}@T{
_id
T}@T{
oid
T}@T{
Return the content
T}
T{
T}@T{
T}@T{
T}@T{
contained in the field
T}
T{
T}@T{
T}@T{
T}@T{
"_id" in the inserted
T}
T{
T}@T{
T}@T{
T}@T{
record.(only displayed
T}
T{
T}@T{
T}@T{
T}@T{
when the parameter "
T}
T{
T}@T{
T}@T{
T}@T{
flag" is "SDB_INSERT_
T}
T{
T}@T{
T}@T{
T}@T{
RETURN_ID" or the
T}
T{
T}@T{
T}@T{
T}@T{
parameter "ReturnOID"
T}
T{
T}@T{
T}@T{
T}@T{
is true)
T}
.TE
.PP
When the function fails, an exception will be thrown and an error message will
be printed.
.SH ERRORS
.PP
The common exceptions of \f[C]insert()\f[] function are as follows:
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Error Code
T}@T{
Error Type
T}@T{
Description
T}@T{
Solution
T}
_
T{
1
T}@T{
\-6
T}@T{
SDB_INVALIDARG
T}@T{
Parameter error
T}@T{
Check whether the
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
parameters are filled
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
in correctly.
T}
T{
2
T}@T{
\-23
T}@T{
SDB_DMS_NOTEXIST
T}@T{
Collection does not
T}@T{
Check whether the
T}
T{
T}@T{
T}@T{
T}@T{
exist.
T}@T{
collection exists.
T}
T{
3
T}@T{
\-34
T}@T{
SDB_DMS_CS_NOTEXIST
T}@T{
Collection space does
T}@T{
Check whether the
T}
T{
T}@T{
T}@T{
T}@T{
not exist.
T}@T{
collection space exists.
T}
T{
4
T}@T{
\-38
T}@T{
SDB_IXM_DUP_KEY
T}@T{
Index key already
T}@T{
Check whether the index
T}
T{
T}@T{
T}@T{
T}@T{
exists.
T}@T{
key of the inserted
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
record exists.
T}
.TE
.PP
When the exception happens, use getLastErrMsg() to get the error message or use
getLastError() to get the error code.
For more details, refer to Troubleshooting.
.SH VERSION
.PP
v3.4 and above
.SH EXAMPLES
.IP \[bu] 2
Insert a record in the collection "sample.employee".
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.insert({name: "Tom", age: 20})
\f[]
.fi
.RE
.IP \[bu] 2
Insert multiple records in the collection "sample.employee".
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.insert([{_id: 20, name: "Mike", age: 15}, {name: "John", age: 25, phone: 123}])
\f[]
.fi
.RE
.IP \[bu] 2
Insert multiple records with duplicate _id keys in the collection
"sample.employee", and specify the parameter "flag" as "SDB_INSERT_CONTONDUP".
.RS 2
.IP
.nf
\f[C]

> db.sample.employee.insert([{_id: 1, a: 1}, {_id: 1, b: 2}, {_id: 3, c: 3}], SDB_INSERT_CONTONDUP)
> db.sample.employee.find()
{
  "_id": 1,
  "a": 1,
}
{
  "_id": 3,
  "c": 3
}
\f[]
.fi
.RE
.IP \[bu] 2
Insert multiple records in the collection "sample.employee", and specify the
parameter "ReturnOID" as true.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.insert([{a: 1}, {b: 1}], {ReturnOID: true})
{
    "_id": [
        {
            "$oid": "5bececdf6404b9295a63cacb"
        },
        {
            "$oid": "5bececdf6404b9295a63cacc"
        }
    ]
    "InsertedNum": 2,
    "DuplicatedNum": 0
}
\f[]
.fi
.RE
.IP \[bu] 2
Create an auto\-increment field in the collection "sample.employee" and insert a
record.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.createAutoIncrement({Field: "ID"})
> db.sample.employee.insert({a: 1})
{
    "InsertedNum": 1,
    "DuplicatedNum": 0,
    "LastGenerateID": 1
}
\f[]
.fi
.RE
