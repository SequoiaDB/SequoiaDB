.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "upsert" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH 名称
.PP
upsert \- 更新集合记录
.SH 语法
.PP
\f[B]db.collectionspace.collection.upsert(<rule>, [cond], [hint], [setOnInsert],
[options])\f[]
.SH 类别
.PP
SdbCollection
.SH 描述
.PP
该函数用于更新集合记录。upsert 方法跟 update
方法都是对记录进行更新，不同的是当使用 cond 参数在集合中匹配不到记录时，update
不做任何操作，而 upsert 方法会做一次插入操作。
.SH 参数
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
参数名
T}@T{
类型
T}@T{
描述
T}@T{
是否必填
T}
_
T{
1
T}@T{
rule
T}@T{
object
T}@T{
更新规则，记录
T}@T{
是
T}
T{
T}@T{
T}@T{
T}@T{
按 rule 的内容更
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
新
T}@T{
T}
T{
2
T}@T{
cond
T}@T{
object
T}@T{
选择条件，为空
T}@T{
否
T}
T{
T}@T{
T}@T{
T}@T{
时，更新所有记
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
录，不为空时，
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
更新符合条件的
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
记录
T}@T{
T}
T{
3
T}@T{
hint
T}@T{
object
T}@T{
指定访问计划
T}@T{
否
T}
T{
4
T}@T{
setOnInsert
T}@T{
object
T}@T{
在做插入操作时
T}@T{
否
T}
T{
T}@T{
T}@T{
T}@T{
向插入的记录中
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
追加字段
T}@T{
T}
T{
5
T}@T{
options
T}@T{
object
T}@T{
可选项，详见
T}@T{
否
T}
T{
T}@T{
T}@T{
T}@T{
options 选项说明
T}@T{
T}
.TE
.PP
options 选项：
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
参数名
T}@T{
类型
T}@T{
描述
T}@T{
默认值
T}
_
T{
1
T}@T{
KeepShardingKey
T}@T{
boolean
T}@T{
为 false 时，将不
T}@T{
false
T}
T{
T}@T{
T}@T{
T}@T{
保留更新规则中
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
的分区键字段，
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
只更新非分区键
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
字段为 true 时，
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
将会保留更新规
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
则中的分区键字
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
段
T}@T{
T}
T{
2
T}@T{
JustOne
T}@T{
boolean
T}@T{
为 true 时，将只
T}@T{
false
T}
T{
T}@T{
T}@T{
T}@T{
更新一条符合条
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
件的记录为
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
false 时，将会更
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
新所有符合条件
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
的记录
T}@T{
T}
.TE
.RS
.PP
\f[B]Note:\f[]
.IP \[bu] 2
参数 hint 的用法与 find() 的相同。
.IP \[bu] 2
当 cond 参数在集合中匹配不到记录时，upsert
会生成一条记录插入到集合中。记录生成规则为：首先从 cond 参数中取出 $et 和 $all
操作符对应的键值对，没有的时候生成空记录。然后使用 rule
规则对其做更新操作，最后加入 setOnInsert 中的键值对。
.IP \[bu] 2
目前分区集合上，不支持更新分区键。如果 \f[C]KeepShardingKey\f[] 为
true，并且更新规则中带有分区键字段，将会报错 \-178。
.IP \[bu] 2
JustOne 为 true 时，只能在单个分区、单个子表上执行。
.RE
.SH 返回值
.PP
函数执行成功时，将返回一个 BSONObj
类型的对象。通过该对象获取成功更新的记录数信息，字段说明如下：
.PP
.TS
tab(@);
l l l l.
T{
0
T}@T{
字段名
T}@T{
类型
T}@T{
描述
T}
_
T{
1
T}@T{
UpdatedNum
T}@T{
int64
T}@T{
成功更新的记录
T}
T{
T}@T{
T}@T{
T}@T{
数，包括匹配但
T}
T{
T}@T{
T}@T{
T}@T{
未发生数据变化
T}
T{
T}@T{
T}@T{
T}@T{
的记录
T}
T{
2
T}@T{
ModifiedNum
T}@T{
int64
T}@T{
成功更新且发生
T}
T{
T}@T{
T}@T{
T}@T{
数据变化的记录
T}
T{
T}@T{
T}@T{
T}@T{
数
T}
T{
3
T}@T{
InsertedNum
T}@T{
int64
T}@T{
成功插入的记录
T}
T{
T}@T{
T}@T{
T}@T{
数
T}
.TE
.PP
函数执行失败时，将抛异常并输出错误信息。
.SH 错误
.PP
\f[C]upsert()\f[] 函数常见异常如下：
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
错误码
T}@T{
错误类型
T}@T{
可能发生的原因
T}@T{
解决办法
T}
_
T{
1
T}@T{
\-178
T}@T{
SDB_UPDATE_SHARD_KEY
T}@T{
分区集合上不支
T}@T{
KeepShardingKey 设置
T}
T{
T}@T{
T}@T{
T}@T{
持更新分区键
T}@T{
为 false，不更新
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
分区键
T}
T{
2
T}@T{
\-347
T}@T{
SDB_COORD_UPDATE_MULTI_
T}@T{
参数 JustOne 为 true
T}@T{
修改匹配条件或
T}
T{
T}@T{
T}@T{
NODES
T}@T{
时，跨多个分区
T}@T{
不使用参数 JustOne
T}
T{
T}@T{
T}@T{
T}@T{
或多个子表更新
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
记录
T}@T{
T}
.TE
.PP
当异常抛出时，可以通过 getLastErrMsg() 获取错误信息或通过 getLastError()
获取错误码。更多错误处理可以参考常见错误处理指南。
.SH 版本
.PP
v2.0 及以上版本
.SH 示例
.PP
假设集合 sample.employee 中有两条记录
.IP
.nf
\f[C]
{
  "_id": {
    "$oid": "516a76a1c9565daf06030000"
  },
  "age": 10,
  "name": "Tom"
}
{
  "_id": {
    "$oid": "516a76a1c9565daf06050000"
  },
  "a": 10,
  "age": 21
}
\f[]
.fi
.IP \[bu] 2
按指定的更新规则更新集合中所有记录，即设置 rule 参数，不设定 cond 和 hint
参数的内容。如下操作等效于使用 update 方法，更新集合 sample.employee
中的所有记录，使用
\f[I]i\f[]\f[I]n\f[]\f[I]c\f[]\f[I]将\f[]\f[I]记\f[]\f[I]录\f[]\f[I]的\f[]\f[I]a\f[]\f[I]g\f[]\f[I]e\f[]\f[I]字\f[]\f[I]段\f[]\f[I]值\f[]\f[I]加\f[]1，\f[I]n\f[]\f[I]a\f[]\f[I]m\f[]\f[I]e\f[]\f[I]字\f[]\f[I]段\f[]\f[I]值\f[]\f[I]更\f[]\f[I]改\f[]\f[I]为\f[]“ \f[I]M\f[]\f[I]i\f[]\f[I]k\f[]\f[I]e\f[]” ，\f[I]对\f[]\f[I]不\f[]\f[I]存\f[]\f[I]在\f[]\f[I]n\f[]\f[I]a\f[]\f[I]m\f[]\f[I]e\f[]\f[I]字\f[]\f[I]段\f[]\f[I]的\f[]\f[I]记\f[]\f[I]录\f[]，set
操作符会将 name 字段和其设定的值插入到记录中，可使用 find 方法查看更新结果
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}, $set: {name: "Mike"}})
{
  "UpdatedNum": 2,
  "ModifiedNum": 2,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06030000"
     },
     "age": 11,
     "name": "Mike"
}
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 22,
     "name":"Mike"
}
Return 2 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
选择符合匹配条件的记录，对这些记录按更新规则更新，即设定 rule 和 cond
参数。如下操作使用 $exists 匹配存在 type 字段的记录，使用 $inc 将这些记录的 age
字段值加 3。在上面给出的两条记录中，都没有 type 字段，此时，upsert
操作会插入一条新的记录，新记录只有 _id 字段和 age 字段名，_id 字段值自动生成，而
age 字段值为 3
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 3}}, {type: {$exists: 1}})
{
  "UpdatedNum": 0,
  "ModifiedNum": 0,
  "InsertedNum": 1
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06030000"
     },
     "age": 11,
     "name": "Mike"
}
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 22,
     "name":"Mike"
}
{
     "_id": {
     "$oid": "516cfc334630a7f338c169b0"
     },
     "age": 3
}
Return 3 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
按访问计划更新记录，假设集合中存在指定的索引名 testIndex，此操作等效于使用
update 方法，使用索引名为 testIndex 的索引访问集合 sample.employee 中 age
字段值大于 20 的记录，将这些记录的 age 字段名加 1
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}}, {age: {$gt: 20}}, {"": "testIndex"})
{
  "UpdatedNum": 1,
  "ModifiedNum": 1,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "a": 10,
     "age": 23,
     "name":"Mike"
}
Return 1 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
使用 setOnInsert 更新记录，由于集合 sample.employee 中 age 字段值大于 30
的记录为空，upsert 在做插入操作时向插入的记录中追加字段 {"name":"Mike"}
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.upsert({$inc: {age: 1}}, {age: {$gt: 30}}, {}, {"name": "Mike"})
{
  "UpdatedNum": 0,
  "ModifiedNum": 0,
  "InsertedNum": 1
}
>
> db.sample.employee.find({"age": 1, "name": "Mike"})
{
     "_id": {
     "$oid": "516a76a1c9565daf06050000"
     },
     "age":1,
     "name":"Mike"
} 
Return 1 row(s).
\f[]
.fi
.RE
.IP \[bu] 2
分区集合 sample.employee，分区键为 {a: 1}，含有以下记录
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.find()
{
  "_id": {
    "$oid": "5c6f660ce700db6048677154"
  },
  "a": 1,
  "b": 1
}
Return 1 row(s).
\f[]
.fi
.PP
指定 KeepShardingKey 参数：不保留更新规则中的分区键字段，只更新了非分区键 b
字段，分区键 a 字段的值没有被更新。
.IP
.nf
\f[C]
> db.sample.employee.upsert({$set: {a: 9, b: 9}}, {}, {}, {}, {KeepShardingKey: false})
{
  "UpdatedNum": 1,
  "ModifiedNum": 1,
  "InsertedNum": 0
}
>
> db.sample.employee.find()
{
  "_id": {
    "$oid": "5c6f660ce700db6048677154"
  },
  "a": 1,
  "b": 9
}
Return 1 row(s).
\f[]
.fi
.PP
指定 KeepShardingKey
参数：保留更新规则中的分区键字段。因为目前不支持更新分区键，所以会报错。
.IP
.nf
\f[C]
> db.sample.employee.upsert({$set: {a: 9}}, {}, {}, {}, {KeepShardingKey: true})
(nofile):0 uncaught exception: \-178
Sharding key cannot be updated
\f[]
.fi
.RE
