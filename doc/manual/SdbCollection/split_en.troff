.\"t
.\" Automatically generated by Pandoc 1.18
.\"
.TH "split" "1" "" "SequoiaDB User Manuals" ""
.hy
.SH NAME
.PP
split \- split data records
.SH SYNOPSIS
.PP
\f[B]db.collectionspace.collection.split(<source group>, <target group>,
<percent>)\f[]
.PP
\f[B]db.collectionspace.collection.split(<source group>, <target group>,
<condition>, [endcondition])\f[]
.SH CATEGORY
.PP
SdbCollection
.SH DESCRIPTION
.PP
This function is used to split the data records in the source partition group
into the target partition group according to the specified conditions.
The source partition group and the target partition group must belong to the
same domain.
.SH PARAMETERS
.SS Range split
.PP
db.collectionspace.collection.split(<source group>, <target group>, <condition>,
[endcondition])
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}@T{
Required or not
T}
_
T{
1
T}@T{
source group
T}@T{
string
T}@T{
Source partition group
T}@T{
required
T}
T{
2
T}@T{
target group
T}@T{
string
T}@T{
Target partition group
T}@T{
required
T}
T{
3
T}@T{
condition
T}@T{
object
T}@T{
Range split condition
T}@T{
required
T}
T{
4
T}@T{
endcondition
T}@T{
object
T}@T{
End range condition
T}@T{
not
T}
.TE
.RS
.PP
\f[B]Note:\f[]
.IP \[bu] 2
"Range" partitioning uses precise conditions, while "Hash" partitioning uses
Partition (number of partitions) conditions.
When the end condition is not selected, the default is the maximum data range
currently contained in the segmentation source.
.IP \[bu] 2
If the specified partition key field is in descending order, such as
{groupingKey: {: < \-1>}, condition (or Partition), The range in the start
condition in the above example should be greater than the range in the end
condition.
The Partition (number of partitions) used by the "Hash‚Äù partition must be an
integer, not other types.
.RE
.SS Percentage split
.PP
db.collectionspace.collection.split(<source group>, <target group>, <percent>)
.PP
.TS
tab(@);
l l l l l.
T{
0
T}@T{
Name
T}@T{
Type
T}@T{
Description
T}@T{
Required or not
T}
_
T{
1
T}@T{
source group
T}@T{
string
T}@T{
Source partition group
T}@T{
required
T}
T{
2
T}@T{
target group
T}@T{
string
T}@T{
Target partition group
T}@T{
required
T}
T{
3
T}@T{
percent
T}@T{
double
T}@T{
Percentage split
T}@T{
required
T}
T{
T}@T{
T}@T{
T}@T{
condition, Value: (0,
T}@T{
T}
T{
T}@T{
T}@T{
T}@T{
100]
T}@T{
T}
.TE
.RS
.PP
\f[B]Note:\f[]
.IP \[bu] 2
Range partition needs to ensure that the source partition group contains data,
which means the collection is not empty.
.IP \[bu] 2
The percentage cannot be 0.
.RE
.SH RETURN VALUE
.PP
When the function executes successfully, there is no return value.
.PP
When the function fails, an exception will be thrown and an error message will
be printed.
.SH ERRORS
.PP
When the exception happens, use getLastErrMsg() to get the error message or use
getLastError() to get the error code.
For more details, refer to Troubleshooting.
.SH VERSION
.PP
v2.0 and above
.SH EXAMPLES
.IP \[bu] 2
Hash partition range split.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.split("group1", "group2", {Partition: 10}, {Partition: 20})
\f[]
.fi
.RE
.IP \[bu] 2
Range partition range split.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.split("group1", "group2", {a: 10}, {a: 10000})
\f[]
.fi
.RE
.IP \[bu] 2
Percentage split.
.RS 2
.IP
.nf
\f[C]
> db.sample.employee.split("group1", "group2", 50) 
\f[]
.fi
.RE
