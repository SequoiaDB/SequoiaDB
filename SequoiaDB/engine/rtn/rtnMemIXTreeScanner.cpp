/*******************************************************************************


   Copyright (C) 2011-2018 SequoiaDB Ltd.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Source File Name = rtnMemIXTreeScanner.cpp

   Descriptive Name = Runtime Index Scanner

   When/how to use: this program may be used on binary and text-formatted
   versions of Runtime component. This file contains code for in memory
   index tree traversal, including advance, pause, resume operations.

   Dependencies: N/A

   Restrictions: N/A

   Change Activity:
   defect Date        Who Description
   ====== =========== === ==============================================
          11/08/2018  YXC Initial Draft

   Last Changed =

*******************************************************************************/
#include "rtnMemIXTreeScanner.hpp"
#include "dmsStorageUnit.hpp"
#include "pmdEDU.hpp"
#include "pmd.hpp"
#include "pdTrace.hpp"
#include "rtnTrace.hpp"

using namespace bson ;

namespace engine
{
   // Description:
   //    _rtnMemIXTreeScanner constructor, set up index related information
   //    and push down predicate information.
   // Input:
   //  indexCB: index control block
   //  predList: predicate list generated by access plan
   //  su: storage unit, not really used except create a local indexCB.
   //    we can't rely on the indexCB to be valid for the life of the scan.
   //    the same. It could be NULL here.
   //  cb: edu control block. When it's not NULL, it can be used to
   //    access monAppCB.
   // Dependency:
   //    All input except su should not be NULL
   _rtnMemIXTreeScanner::_rtnMemIXTreeScanner ( ixmIndexCB *pIndexCB,
                                                rtnPredicateList *predList,
                                                _dmsStorageUnit  *su,
                                                _pmdEDUCB        *cb,
                                                BOOLEAN indexCBOwnned )
   :_rtnIXScanner( pIndexCB, predList, su, cb, indexCBOwnned ),
    _listIterator(*predList)
   {
      _pTransCB = pmdGetKRCB()->getTransCB() ;
      _available = FALSE ;
      _treeLatchHeld = FALSE ;

      reset() ;
   }

   // destructor
   _rtnMemIXTreeScanner::~_rtnMemIXTreeScanner()
   {
      if ( _treeLatchHeld )
      {
         isReadonly() ? _memIdxTree->unlockS() :  _memIdxTree->unlockX() ;
         _treeLatchHeld = FALSE ;
      }
   }

   IXScannerType _rtnMemIXTreeScanner::getType() const
   {
      return SCANNER_TYPE_MEM_TREE ;
   }

   IXScannerType _rtnMemIXTreeScanner::getCurScanType() const
   {
      return SCANNER_TYPE_MEM_TREE ;
   }

   void _rtnMemIXTreeScanner::disableByType( IXScannerType type )
   {
      /// do nothing
   }

   INT32 _rtnMemIXTreeScanner::getLockModeByType( IXScannerType type ) const
   {
      if ( type == SCANNER_TYPE_MEM_TREE && _treeLatchHeld )
      {
         return isReadonly() ? SHARED : EXCLUSIVE ;
      }
      return -1 ;
   }

   BOOLEAN _rtnMemIXTreeScanner::isAvailable() const
   {
      return _available ;
   }

   void _rtnMemIXTreeScanner::reset()
   {
      _savedObj      = BSONObj() ;
      _savedRID.reset() ;
      _listIterator.reset() ;

      if ( _pInfo )
      {
         _pInfo->clear() ;
      }
      _init = FALSE ;
   }

   INT32 _rtnMemIXTreeScanner::init()
   {
      INT32 rc = SDB_OK ;

      if ( !_pTransCB || !_pTransCB->getOldVCB() )
      {
         PD_LOG( PDERROR, "TransCB or OldVerionCB is NULL" ) ;
         rc = SDB_SYS ;
         goto error ;
      }

      rc = _rtnIXScanner::init() ;
      if ( rc )
      {
         goto error ;
      }

      _gid._csID = _su->CSID() ;
      _gid._clID = _indexCB->getMBID() ;
      _gid._idxLID = getIdxLID() ;

      _available = FALSE ;

   done:
      return rc ;
   error:
      goto done ;
   }

   // Description:
   //    In certain cases we need to change the scanner's current location
   // to a given key and rid in the in memory tree. The cases include but
   // not limited to: after insertion/deletion of indexes. We need both
   // key and rid because the key might not be unique. In case this is called
   // during first init time, the keyObj is a dummy key. We will endup get
   // whatever the first key based on the direction. Otherwise, we will use
   // a savedObj and savedRib
   //
   // Input:
   //    keyObj: BSONObj containing the key
   //    rid: record id
   // Output:
   //    _curIndexIter, _savedObj, _savedRID, _init
   //    implicitly setup up when found the new location.
   // Return:
   //    error code from find/locate. Those are sever system error like memory or
   //    disk page error
   // Dependency:
   //    Caller need to hold mbLatch
   //    Caller should hold the in memory tree latch.
   // PD_TRACE_DECLARE_FUNCTION ( SDB__RTNMEMIXTREESCAN_RELORID1, "_rtnMemIXTreeScanner::relocateRID" )
   INT32 _rtnMemIXTreeScanner::relocateRID ( const BSONObj &keyObj,
                                             const dmsRecordID &rid )
   {
      INT32 rc = SDB_OK ;
      PD_TRACE_ENTRY ( SDB__RTNMEMIXTREESCAN_RELORID1 ) ;
      BOOLEAN hasResume = FALSE ;
      BOOLEAN found = FALSE ;

      if ( !_treeLatchHeld )
      {
         _savedObj = BSONObj() ;

         rc = resumeScan() ;
         if ( rc )
         {
            PD_LOG( PDERROR, "Resume scan failed, rc: %d", rc ) ;
            goto error ;
         }
         hasResume = TRUE ;
      }

      _savedObj = keyObj.getOwned() ;
      _savedRID = rid ;

      if ( _treeLatchHeld )
      {
         rc = relocateRID( found ) ;
         if ( rc )
         {
            goto error ;
         }

         if ( found && !isReadonly() )
         {
            _savedRID._offset -= 1 ;
            found = FALSE ;
         }

         // mark _init to true so that advance won't call keyLocate again
         _init = TRUE ;
         // remove the eof flag so we will restart scan on the tree
         _eof = _memIdxTree->isPosValid( _curIndexPos ) ? FALSE : TRUE ;
      }

   done :
      if ( hasResume )
      {
         pauseScan() ;
      }
      PD_TRACE_EXITRC ( SDB__RTNMEMIXTREESCAN_RELORID1, rc ) ;
      return rc ;
   error :
      goto done ;
   }

   // relocate based on saved object and saved recordID
   INT32 _rtnMemIXTreeScanner::relocateRID( BOOLEAN &found )
   {
      INT32 rc = SDB_OK ;
      found = FALSE ;
      monAppCB * pMonAppCB = _cb ? _cb->getMonAppCB() : NULL ;

      SDB_ASSERT( _available, "Must be available" ) ;

      rc = _memIdxTree->locate( _savedObj, _savedRID, _curIndexPos,
                                found, _direction ) ;
      if ( rc )
      {
         if ( SDB_IXM_EOC != rc )
         {
            PD_LOG( PDERROR, "Failed to locate in tree by obj(%s) and "
                    "rid(%d,%d), rc: %d", _savedObj.toString().c_str(),
                    _savedRID._extent, _savedRID._extent, rc ) ;
            goto error ;
         }
         /// reset position
         rc = SDB_OK ;

         PD_LOG( PDDEBUG, "Relocate to end, obj(%s), rid(%d,%d)",
                 _savedObj.toString().c_str(), _savedRID._extent,
                 _savedRID._offset ) ;

         _memIdxTree->resetPos( _curIndexPos ) ;
         goto done ;
      }
      else if ( found &&
                _memIdxTree->getNodeData( _curIndexPos ).isRecordDeleted() )
      {
         found = FALSE ;
      }

      PD_LOG( PDDEBUG, "Relocate to obj(%s) with rid(%d,%d), found(%d)",
              _savedObj.toString().c_str(), _savedRID._extent,
              _savedRID._offset, found ) ;

      DMS_MON_OP_COUNT_INC( pMonAppCB, MON_INDEX_READ, 1 ) ;

   done:
      return rc ;
   error:
      goto done ;
   }

   // Description
   //    advance() is called between resumeScan() and pauseScan() to look
   //    for the next best match index in the in memory search tree.
   //    caller must make acquire the table lock before calling resumeScan
   //    and must release the table lock right after calling pauseScan
   //
   // Input:
   //    N/A
   // Output:
   //    rid: record id retrieved
   //    implicitly setup up when found the new location.
   // Return:
   //    SDB_OK: rid is set to dmsRecordID
   //    SDB_IXM_EOC: hit the end of index
   //    SDB_IXM_DEDUP_BUF_MAX:  hit max dedup buffer
   // Dependency:
   //    mbLatch is held, tree latch is held
   //PD_TRACE_DECLARE_FUNCTION ( SDB__RTNMEMIXTREESCAN_ADVANCE, "_rtnMemIXTreeScanner::advance" )
   INT32 _rtnMemIXTreeScanner::advance ( dmsRecordID &rid )
   {
      PD_TRACE_ENTRY ( SDB__RTNMEMIXTREESCAN_ADVANCE ) ;

      INT32 rc             = SDB_OK ;
      monAppCB * pMonAppCB = _cb ? _cb->getMonAppCB() : NULL ;

   begin:
      // first time run, _curIndexPos was set to invalid, we need to
      // locate the first key
      if ( !_init )
      {
         // tree never exist, finsh the scan
         if ( !_available )
         {
            rc = SDB_IXM_EOC ;
            goto done ;
         }

         rc = _memIdxTree->keyLocate( _curIndexPos, BSONObj(), 0, FALSE,
                                      _listIterator.cmp(),
                                      _listIterator.inc(),
                                      _direction ) ;
         if ( rc )
         {
            if ( SDB_IXM_EOC != rc )
            {
               PD_LOG( PDERROR, "Failed to key locate, rc: %d", rc ) ;
               goto error ;
            }
            rc = SDB_OK ;
            _memIdxTree->resetPos( _curIndexPos ) ;
         }

         _init = TRUE ;
      }
      // otherwise _curIndexIter is pointing to the previous scanned location,
      // we should start from there
      else
      {
         SDB_ASSERT( _treeLatchHeld, "tree latch should be held" ) ;
         // if the tree is empty, consider as EOC. We should check during each
         // round because as soon as we pause, someone else can
         // commit the deletion of certain keys.
         // make sure the current _memIdxTree is not the end
         if ( !_memIdxTree->isPosValid( _curIndexPos ) )
         {
            rc = SDB_IXM_EOC ;
            goto done ;
         }

         // _savedRID/_savedObj should always be NULL
         // unless we have pauseScan(), resumeScan(), found the
         // index structure is changed and we have called relocateRID(),
         // in that case _savedRID may not be NULL for readonly mode

         // in write mode, the possible NULL savedRID is that when the
         // previous read is a psuedo-delete, note resumeScan() shouldn't set
         // _savedRID to NULL in this case

         // In such scenario, we advance to next element
         if ( _savedRID.isNull() )
         {
            rc = _memIdxTree->advance( _curIndexPos, _direction ) ;
            if ( rc )
            {
               if ( SDB_IXM_EOC != rc )
               {
                  PD_LOG( PDERROR, "Advance memery tree to next by "
                          "direction(%d) failed, rc: %d", _direction, rc ) ;
                  goto error ;
               }
               rc = SDB_OK ;
               _memIdxTree->resetPos( _curIndexPos ) ;
            }
         }
         else if ( !isReadonly() )
         {
            // if it's update or delete index scan, the index structure may get
            // changed so everytime we have to compare _curIndexPos and onmem
            // rid, as well as the stored object

            BOOLEAN isSame = FALSE ;

            rc = isCursorSame( _savedObj, _savedRID, isSame ) ;
            if ( rc )
            {
               goto error ;
            }

            // if not the same, we must have something changed in
            // the index, let's relocate RID
            if ( !isSame )
            {
               rc = relocateRID( isSame ) ;
               if ( rc )
               {
                  PD_LOG ( PDERROR, "Failed to relocate RID, rc: %d", rc ) ;
                  goto error ;
               }
               if ( isSame && ( !getSharedInfo() ||
                                !getSharedInfo()->exists( _savedRID ) ) )
               {
                  isSame = FALSE ;
               }
            }
            // if both on recordRID and key object are the same, let's
            // say the index is not changed, that means we should move on
            // to the next.
            if ( isSame )
            {
               rc = _memIdxTree->advance( _curIndexPos, _direction ) ;
               if ( rc )
               {
                  if ( SDB_IXM_EOC != rc )
                  {
                     PD_LOG( PDERROR, "Advance memery tree to next by "
                             "direction(%d) failed, rc: %d", _direction, rc ) ;
                     goto error ;
                  }
                  rc = SDB_OK ;
                  _memIdxTree->resetPos( _curIndexPos ) ;
               }
            }
         } // if ( !isReadonly() )
      }

      // after getting the first key location or advanced to next, let's
      // exame if this index key is what we want
      while ( TRUE )
      {
         // after getting _curIndexPos, we have to check if it's null
         if ( !_memIdxTree->isPosValid( _curIndexPos ) )
         {
            rc = SDB_IXM_EOC ;
            goto done ;
         }

         try
         {
            const preIdxTreeNodeValue& nodeVal =
               _memIdxTree->getNodeData( _curIndexPos ) ;
            const preIdxTreeNodeKey& nodeKey =
               _memIdxTree->getNodeKey( _curIndexPos ) ;

            // update monitor counters under latch
            DMS_MON_OP_COUNT_INC( pMonAppCB, MON_INDEX_READ, 1 ) ;

            if ( nodeVal.isRecordDeleted() )
            {
               _savedRID.reset() ;
               goto begin ;
            }

            _curKeyObj = nodeKey.getKeyObj() ;

            // compare the key in list iterator
            rc = _listIterator.advance ( _curKeyObj ) ;
            // if -2, that means we hit end of iterator, so all other keys in
            // index are not within our select range
            if ( -2 == rc )
            {
               rc = SDB_IXM_EOC ;
               goto done ;
            }
            // if >=0, that means the key is not selected and we want to
            // further advance the key in index.
            else if ( rc >= 0 )
            {
               // Starting from _curIndexIter, move the key the best matching
               // key based on the updated listIterator
               rc = _memIdxTree->keyAdvance ( _curIndexPos, _curKeyObj, rc,
                                              _listIterator.after(),
                                              _listIterator.cmp(),
                                              _listIterator.inc(),
                                              _direction ) ;
               if ( rc )
               {
                  if ( SDB_IXM_EOC != rc )
                  {
                     PD_LOG( PDERROR, "Failed to key advance in memory tree, "
                             "rc: %d", rc ) ;
                     goto error ;
                  }
                  rc = SDB_OK ;
                  _memIdxTree->resetPos( _curIndexPos ) ;
               }
               continue ;
            }
            // otherwise let's attempt to get dms rid
            else
            {
               // get RID from iterator
               _savedRID = nodeKey.getRID() ;
               // RID saved in the in-memory tree should be valid
               SDB_ASSERT( !_savedRID.isNull(),
                           "The RID from curIndexIter should not be NULL" ) ;

               if ( !_insert2Dup( _savedRID ) )
               {
                  // if we are able to find the recordid in dupBuffer, that
                  // means we've already processed the record, so let's also
                  // jump back to begin
                  _savedRID.reset() ;
                  goto begin ;
               }

               // make sure we don't hit maximum size of dedup buffer
               /*if ( _pInfo && _pInfo->isUpToLimit() )
               {
                  rc = SDB_IXM_DEDUP_BUF_MAX ;
                  goto error ;
               }*/

               rid = _savedRID ;

               // if we are write mode, let's record the _savedObj as well
               if ( !isReadonly() )
               {
                  _savedObj = _curKeyObj.getOwned() ;
               }
               else
               {
                  // in readonly scenario, _savedRID should always be null
                  // unless pauseScan() is called
                  _savedRID.reset() ;
               }
               rc = SDB_OK ;
               break ;
            }
         }
         catch( std::bad_alloc &e )
         {
            PD_LOG( PDERROR, "Occur exception: %s", e.what() ) ;
            rc = SDB_OOM ;
            goto error ;
         }
         catch( std::exception &e )
         {
            PD_LOG( PDERROR, "Occur exception: %s", e.what() ) ;
            rc = SDB_SYS ;
            goto error ;
         }
      } // while ( TRUE )

   done :
      if ( rc == SDB_IXM_EOC )
      {
         _eof = TRUE ;
         rid.reset() ;

         PD_LOG( PDDEBUG, "Hit end with obj(%s)",
                 _curKeyObj.toString().c_str() ) ;
      }
      PD_TRACE_EXITRC( SDB__RTNMEMIXTREESCAN_ADVANCE, rc ) ;
      return rc ;
   error :
      goto done ;
   }

   // save the bson key + rid for the current index rid, before releasing
   // X latch on the collection
   // we have to call resumeScan after getting X latch again just in case
   // other sessions changed tree structure
   // this is used for readonly query scan only, any update need to perform
   // on latest data from disk.
   // PD_TRACE_DECLARE_FUNCTION ( SDB__RTNMEMIXTREESCAN_PAUSESCAN, "_rtnMemIXTreeScanner::pauseScan" )
   INT32 _rtnMemIXTreeScanner::pauseScan()
   {
      INT32 rc = SDB_OK ;
      PD_TRACE_ENTRY ( SDB__RTNMEMIXTREESCAN_PAUSESCAN ) ;

      // do nothing if the in memory tree is not initialized or haven't done
      // first round or we don't have tree latch. There are special boundary
      // case in IXSec scan where we may call pause scan twice, the second
      // pause may become no op due to the treeLatch held condition.
      if ( !_init || !_treeLatchHeld ||
           !_memIdxTree->isPosValid( _curIndexPos ) )
      {
         goto done ;
      }

      // for write mode, since we write _savedRID and _savedObj in advance, we
      // don't do it here
      if ( isReadonly() )
      {
         try
         {
            const preIdxTreeNodeKey& nodeKey =
               _memIdxTree->getNodeKey( _curIndexPos ) ;
            _savedRID = nodeKey.getRID() ;
            _savedObj = nodeKey.getKeyObj().getOwned() ;

            PD_LOG( PDDEBUG, "Paused in obj(%s) with rid(%d,%d)",
                    _savedObj.toString().c_str(),
                    _savedRID._extent, _savedRID._offset ) ;
         }
         catch ( std::exception &e )
         {
            PD_LOG ( PDERROR, "Occur exception: %s", e.what() ) ;
            rc = SDB_SYS ;
            goto error ;
         }
      }

   done:
      // Release latch on the tree
      if ( _treeLatchHeld )
      {
         isReadonly() ? _memIdxTree->unlockS() :  _memIdxTree->unlockX() ;
         _treeLatchHeld = FALSE ;
      }

      PD_TRACE_EXITRC ( SDB__RTNMEMIXTREESCAN_PAUSESCAN, rc ) ;
      return rc ;
   error :
      goto done ;
   }

   // restoring the bson key and rid for the current index scan. This is done by
   // comparing the _curIndexIter against a new find of iterator in the tree
   // with the saved keyObj+rid.
   // If so it means there's no change in this in memory tree, and we
   // can move on the from the current index rid. Otherwise we have to locate
   // the new position for the saved key+rid
   // this is used in readonly query scan only
   // PD_TRACE_DECLARE_FUNCTION ( SDB__RTNMEMIXTREESCAN_RESUMESCAN, "_rtnMemIXTreeScanner::resumeScan" )
   INT32 _rtnMemIXTreeScanner::resumeScan( BOOLEAN *pIsCursorSame )
   {
      PD_TRACE_ENTRY ( SDB__RTNMEMIXTREESCAN_RESUMESCAN ) ;
      INT32 rc = SDB_OK ;
      BOOLEAN isSame = TRUE ;
      oldVersionCB * oldVCB = _pTransCB->getOldVCB() ;

      _curKeyObj = BSONObj() ;

      SDB_ASSERT( !_treeLatchHeld, "Tree latch shouldn't be held" ) ;

      if ( _treeLatchHeld )
      {
         goto done ;
      }

      /// when the tree is not exist
      if ( !_memIdxTree.get() )
      {
         _memIdxTree = oldVCB->getIdxTree( _gid, FALSE ) ;

         if ( !_memIdxTree.get() )
         {
            _eof = TRUE ;
            _available = FALSE ;
            goto done ;
         }

         _available = TRUE ;
         _memIdxTree->resetPos( _curIndexPos ) ;
      }

      if ( !_memIdxTree->isValid() )
      {
         _eof = TRUE ;
         _available = FALSE ;
         rc = SDB_DMS_INVALID_INDEXCB ;
         goto error ;
      }

      if ( isReadonly() )
      {
         _memIdxTree->lockS() ;
      }
      else
      {
         _memIdxTree->lockX() ;
      }
      _treeLatchHeld = TRUE ;

      // haven't locate the rid in the tree yet, the first run of advance
      // will handle it
      if ( !_init || !_memIdxTree->isPosValid( _curIndexPos ) ||
           _savedObj.isEmpty() )
      {
         rc = SDB_OK ;
         goto done ;
      }

      // if pause didn't save anything, we don't know where to
      // start the scan. We will skip and do relocate
      // iterator is the same
      if ( _curIndexPos == _memIdxTree->find( &_savedObj, _savedRID ) &&
           !_memIdxTree->getNodeData( _curIndexPos ).isRecordDeleted() )
      {
         // this means the last scaned record is still here
         isSame = TRUE ;
         _curKeyObj = _savedObj ;
      }
      else
      {
         isSame = FALSE ;
      }

      if ( !isReadonly() )
      {
         goto done ;
      }

      if ( isSame )
      {
         // this means the last scaned record is still here, so let's
         // reset _savedRID so that we'll call advance()
         _savedRID.reset() ;
      }
      else
      {
         // when we get here, it means something changed and we need to
         // relocateRID
         // note relocateRID may relocate to the index that already read.
         // However after advance() returning the RID we'll check if the
         // index already has been read, so we should be save to not
         // reset _savedRID
         rc = relocateRID( isSame ) ;
         if ( rc )
         {
            PD_LOG ( PDERROR, "Failed to relocate RID, rc: %d", rc ) ;
            goto error ;
         }
         if ( isSame )
         {
            _savedRID.reset() ;
            _curKeyObj = _savedObj ;
            goto done ;
         }
      }

   done :
      if ( pIsCursorSame )
      {
         *pIsCursorSame = isSame ;
      }
      PD_TRACE_EXITRC ( SDB__RTNMEMIXTREESCAN_RESUMESCAN, rc ) ;
      return rc ;
   error :
      if( _treeLatchHeld )
      {
         isReadonly() ? _memIdxTree->unlockS() : _memIdxTree->unlockX() ;
         _treeLatchHeld = FALSE ;
      }
      goto done ;
   }

   INT32 _rtnMemIXTreeScanner::isCursorSame( const BSONObj &saveObj,
                                             const dmsRecordID &saveRID,
                                             BOOLEAN &isSame )
   {
      isSame = FALSE ;

      if ( !_available )
      {
         // tree never exist, then we consider it as same and don't
         // bother to work on it
         isSame = TRUE ;
      }
      else if ( _treeLatchHeld )
      {
         INDEX_TREE_CPOS findPos = _memIdxTree->find( &saveObj, saveRID ) ;
         if ( _memIdxTree->isPosValid( findPos ) &&
              _curIndexPos == findPos &&
              !_memIdxTree->getNodeData( _curIndexPos ).isRecordDeleted() )
         {
            isSame = TRUE ;
         }
      }

      return SDB_OK ;
   }

   rtnPredicateListIterator* _rtnMemIXTreeScanner::getPredicateListInterator()
   {
      return &_listIterator ;
   }

}

